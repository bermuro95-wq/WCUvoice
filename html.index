<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WCUVoice - Wachemo University Student Platform</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <style>
        /* Global Styles */
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --success: #2ecc71;
            --warning: #f39c12;
            --danger: #e74c3c;
            --gray: #95a5a6;
            --dark-gray: #7f8c8d;
        }

        [data-theme="dark"] {
            --primary: #34495e;
            --secondary: #2980b9;
            --accent: #c0392b;
            --light: #2c3e50;
            --dark: #ecf0f1;
            --gray: #7f8c8d;
            --dark-gray: #95a5a6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--light);
            color: var(--dark);
            transition: all 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 15px;
        }

        /* Header Styles */
        header {
            background-color: var(--primary);
            color: white;
            padding: 1rem 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo img {
            height: 40px;
        }

        .logo h1 {
            font-size: 1.5rem;
        }

        nav ul {
            display: flex;
            list-style: none;
            gap: 20px;
        }

        nav a {
            color: white;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        nav a:hover {
            background-color: rgba(255,255,255,0.1);
        }

        .user-menu {
            position: relative;
        }

        .user-dropdown {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            background-color: white;
            color: var(--dark);
            min-width: 200px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 4px;
            overflow: hidden;
            z-index: 10;
        }

        .user-dropdown.show {
            display: block;
        }

        .user-dropdown a {
            display: block;
            padding: 10px 15px;
            color: var(--dark);
            text-decoration: none;
            border-bottom: 1px solid #eee;
        }

        .user-dropdown a:hover {
            background-color: #f5f5f5;
        }

        .auth-buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background-color: var(--secondary);
            color: white;
        }

        .btn-secondary {
            background-color: transparent;
            border: 1px solid white;
            color: white;
        }

        .btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        /* Main Content */
        main {
            min-height: calc(100vh - 150px);
            padding: 2rem 0;
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* Home Page */
        .home-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        .posts-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .post-card {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .post-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .post-author {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .post-title {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        .post-content {
            margin-bottom: 15px;
        }

        .post-tags {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .tag {
            background-color: #e0e0e0;
            padding: 3px 8px;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        .post-actions {
            display: flex;
            gap: 15px;
        }

        .action-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--gray);
        }

        .action-btn:hover {
            color: var(--secondary);
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .sidebar-card {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .sidebar-title {
            font-size: 1.1rem;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }

        .trending-list, .category-list {
            list-style: none;
        }

        .trending-list li, .category-list li {
            padding: 8px 0;
            border-bottom: 1px solid #f5f5f5;
        }

        .trending-list li:last-child, .category-list li:last-child {
            border-bottom: none;
        }

        /* Forms */
        .form-container {
            max-width: 500px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .form-control {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--secondary);
        }

        /* Profile Page */
        .profile-header {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .profile-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
        }

        .profile-info h2 {
            margin-bottom: 10px;
        }

        .profile-stats {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--gray);
        }

        /* Footer */
        footer {
            background-color: var(--primary);
            color: white;
            padding: 2rem 0;
        }

        .footer-content {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 30px;
        }

        .footer-section h3 {
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .footer-section ul {
            list-style: none;
        }

        .footer-section ul li {
            margin-bottom: 8px;
        }

        .footer-section a {
            color: #ddd;
            text-decoration: none;
        }

        .footer-section a:hover {
            color: white;
            text-decoration: underline;
        }

        .copyright {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 0.9rem;
            color: #ddd;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .home-grid {
                grid-template-columns: 1fr;
            }
            
            .footer-content {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .header-content {
                flex-direction: column;
                gap: 15px;
            }
            
            nav ul {
                flex-wrap: wrap;
                justify-content: center;
            }
        }

        @media (max-width: 480px) {
            .footer-content {
                grid-template-columns: 1fr;
            }
            
            .profile-header {
                flex-direction: column;
                text-align: center;
            }
            
            .profile-stats {
                justify-content: center;
            }
        }

        /* Utility Classes */
        .text-center {
            text-align: center;
        }
        
        .mb-20 {
            margin-bottom: 20px;
        }
        
        .mt-20 {
            margin-top: 20px;
        }
        
        .hidden {
            display: none;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 4px;
            color: white;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            animation: slideIn 0.3s ease;
        }
        
        .notification.success {
            background-color: var(--success);
        }
        
        .notification.error {
            background-color: var(--danger);
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .dark-mode-toggle {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 1.2rem;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <i class="fas fa-comments"></i>
                    <h1>WCUVoice</h1>
                </div>
                
                <nav>
                    <ul>
                        <li><a href="#" class="nav-link" data-page="home">Home</a></li>
                        <li><a href="#" class="nav-link" data-page="discussions">Discussions</a></li>
                        <li><a href="#" class="nav-link" data-page="messages">Messages</a></li>
                        <li><a href="#" class="nav-link" data-page="about">About Us</a></li>
                        <li><a href="#" class="nav-link" data-page="contact">Contact</a></li>
                    </ul>
                </nav>
                
                <div class="user-menu">
                    <button id="userMenuBtn" class="btn btn-secondary hidden">
                        <i class="fas fa-user"></i> <span id="userName">User</span> <i class="fas fa-caret-down"></i>
                    </button>
                    
                    <div class="user-dropdown" id="userDropdown">
                        <a href="#" class="nav-link" data-page="profile"><i class="fas fa-user"></i> Profile</a>
                        <a href="#" class="nav-link" data-page="settings"><i class="fas fa-cog"></i> Settings</a>
                        <a href="#" id="logoutBtn"><i class="fas fa-sign-out-alt"></i> Logout</a>
                    </div>
                    
                    <div class="auth-buttons" id="authButtons">
                        <button class="btn btn-secondary" id="loginBtn">Login</button>
                        <button class="btn btn-primary" id="signupBtn">Sign Up</button>
                    </div>
                </div>
                
                <button class="dark-mode-toggle" id="darkModeToggle">
                    <i class="fas fa-moon"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main>
        <div class="container">
            <!-- Home Page -->
            <div id="home" class="page active">
                <h2 class="mb-20">Recent Discussions</h2>
                
                <div class="home-grid">
                    <div class="posts-container" id="postsContainer">
                        <!-- Posts will be dynamically loaded here -->
                    </div>
                    
                    <div class="sidebar">
                        <div class="sidebar-card">
                            <h3 class="sidebar-title">Trending Topics</h3>
                            <ul class="trending-list" id="trendingList">
                                <!-- Trending topics will be dynamically loaded here -->
                            </ul>
                        </div>
                        
                        <div class="sidebar-card">
                            <h3 class="sidebar-title">Categories</h3>
                            <ul class="category-list" id="categoryList">
                                <!-- Categories will be dynamically loaded here -->
                            </ul>
                        </div>
                        
                        <div class="sidebar-card">
                            <h3 class="sidebar-title">Create New Post</h3>
                            <p>Start a discussion about campus issues or events.</p>
                            <button class="btn btn-primary" id="createPostBtn">Create Post</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Other pages will be implemented similarly -->
            <div id="discussions" class="page">
                <h2>All Discussions</h2>
                <p>Discussion page content will be loaded here.</p>
            </div>
            
            <div id="messages" class="page">
                <h2>Messages</h2>
                <p>Messaging system will be implemented here.</p>
            </div>
            
            <div id="profile" class="page">
                <h2>User Profile</h2>
                <div class="profile-header" id="profileHeader">
                    <!-- Profile content will be dynamically loaded here -->
                </div>
            </div>
            
            <div id="about" class="page">
                <h2>About WCUVoice</h2>
                <p>WCUVoice is a platform created for Wachemo University students to discuss campus issues, share ideas, and connect with fellow students.</p>
                
                <h3>Developer Information</h3>
                <p><strong>Developer:</strong> Yoseph Abebe Ersedo</p>
                <p><strong>University:</strong> Wachemo University</p>
                <p><strong>Department:</strong> Information Systems</p>
                <p><strong>Year:</strong> 2025</p>
                <p><strong>Email:</strong> jossyabebe92@gmail.com</p>
            </div>
            
            <div id="contact" class="page">
                <h2>Contact Us</h2>
                <p>If you have any questions or suggestions, feel free to reach out to us:</p>
                
                <div class="form-container">
                    <form id="contactForm">
                        <div class="form-group">
                            <label for="contactName">Your Name</label>
                            <input type="text" id="contactName" class="form-control" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="contactEmail">Your Email</label>
                            <input type="email" id="contactEmail" class="form-control" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="contactSubject">Subject</label>
                            <input type="text" id="contactSubject" class="form-control" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="contactMessage">Message</label>
                            <textarea id="contactMessage" class="form-control" rows="5" required></textarea>
                        </div>
                        
                        <button type="submit" class="btn btn-primary">Send Message</button>
                    </form>
                </div>
                
                <div class="mt-20">
                    <h3>Other Contact Methods</h3>
                    <p><strong>Phone:</strong> 09-17-33-21-99</p>
                    <p><strong>Email:</strong> jossyabebe92@gmail.com</p>
                </div>
            </div>
            
            <!-- Authentication Pages -->
            <div id="login" class="page">
                <div class="form-container">
                    <h2 class="text-center">Login to WCUVoice</h2>
                    
                    <form id="loginForm">
                        <div class="form-group">
                            <label for="loginEmail">Email</label>
                            <input type="email" id="loginEmail" class="form-control" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="loginPassword">Password</label>
                            <input type="password" id="loginPassword" class="form-control" required>
                        </div>
                        
                        <button type="submit" class="btn btn-primary" style="width: 100%;">Login</button>
                    </form>
                    
                    <div class="text-center mt-20">
                        <p>Don't have an account? <a href="#" id="goToSignup">Sign up here</a></p>
                    </div>
                </div>
            </div>
            
            <div id="signup" class="page">
                <div class="form-container">
                    <h2 class="text-center">Create WCUVoice Account</h2>
                    
                    <form id="signupForm">
                        <div class="form-group">
                            <label for="signupFullName">Full Name</label>
                            <input type="text" id="signupFullName" class="form-control" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="signupEmail">Email</label>
                            <input type="email" id="signupEmail" class="form-control" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="signupPassword">Password</label>
                            <input type="password" id="signupPassword" class="form-control" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="signupDepartment">Department</label>
                            <select id="signupDepartment" class="form-control" required>
                                <option value="">Select Department</option>
                                <!-- Departments will be loaded dynamically -->
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="signupYear">Year of Study</label>
                            <select id="signupYear" class="form-control" required>
                                <option value="">Select Year</option>
                                <option value="1">1st Year</option>
                                <option value="2">2nd Year</option>
                                <option value="3">3rd Year</option>
                                <option value="4">4th Year</option>
                                <option value="5">5th Year</option>
                                <option value="6">6th Year</option>
                                <option value="7">7th Year</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="signupStudentId">Student ID</label>
                            <input type="text" id="signupStudentId" class="form-control" required>
                        </div>
                        
                        <button type="submit" class="btn btn-primary" style="width: 100%;">Create Account</button>
                    </form>
                    
                    <div class="text-center mt-20">
                        <p>Already have an account? <a href="#" id="goToLogin">Login here</a></p>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>WCUVoice</h3>
                    <p>A platform for Wachemo University students to discuss campus issues and connect with each other.</p>
                </div>
                
                <div class="footer-section">
                    <h3>Quick Links</h3>
                    <ul>
                        <li><a href="#" class="nav-link" data-page="home">Home</a></li>
                        <li><a href="#" class="nav-link" data-page="discussions">Discussions</a></li>
                        <li><a href="#" class="nav-link" data-page="about">About Us</a></li>
                        <li><a href="#" class="nav-link" data-page="contact">Contact</a></li>
                    </ul>
                </div>
                
                <div class="footer-section">
                    <h3>Resources</h3>
                    <ul>
                        <li><a href="#">FAQ</a></li>
                        <li><a href="#">Terms of Service</a></li>
                        <li><a href="#">Privacy Policy</a></li>
                        <li><a href="#">Community Guidelines</a></li>
                    </ul>
                </div>
                
                <div class="footer-section">
                    <h3>Contact Info</h3>
                    <ul>
                        <li>Developer: Yoseph Abebe Ersedo</li>
                        <li>Email: jossyabebe92@gmail.com</li>
                        <li>Phone: 09-17-33-21-99</li>
                        <li>Wachemo University</li>
                    </ul>
                </div>
            </div>
            
            <div class="copyright">
                &copy; 2025 WCUVoice. All rights reserved. Developed by Yoseph Abebe Ersedo.
            </div>
        </div>
    </footer>

    <!-- Firebase Configuration and App Logic -->
    <script>
        










// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyACV46RhY3agDexuzGBYlBFZLn2dc_4oV4",
  authDomain: "wcuvoice.firebaseapp.com",
  projectId: "wcuvoice",
  storageBucket: "wcuvoice.firebasestorage.app",
  messagingSenderId: "777396220141",
  appId: "1:777396220141:web:e7c14f2587ea7e3f775ce4"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();















        // Departments data
        const departments = [
            "Architecture", "Chemical Engineering", "Civil Engineering", "Computer Science",
            "Construction Technology and Management", "Electrical and Computer Engineering",
            "Electro-Mechanical Engineering", "Surveying Engineering", "Information Systems",
            "Information Technology", "Mechanical Engineering", "Software Engineering",
            "Hydraulic and Water Resource Engineering", "Biomedical Engineering", "Biology",
            "Chemistry", "Mathematics", "Statistics", "Biotechnology", "Geology", "Sport Science",
            "Industrial Chemistry", "Anesthesia", "Medicine", "Midwifery", "Comprehensive Nursing",
            "Public Health", "Health Informatics", "Medical Laboratory Technology", "Pharmacy",
            "Surgical Nursing", "Pediatric and Child Health Nursing", "Dental Medicine",
            "Animal Science", "Horticulture", "Natural Resource Management", "Plant Science",
            "Environmental Science", "Food Science and Postharvest Technology", "Agro Economics",
            "Rural Development and Agricultural Extension", "Accounting and Finance", "Management",
            "Economics", "Marketing Management", "Public Administration and Development Management",
            "Tourism and Hotel Management", "Political Science and International Relations",
            "English Language and Literature", "Geography and Environmental Studies",
            "Hadiyissa Language and Literature", "Sociology", "History and Heritage Management",
            "Governance and Development Studies", "Journalism", "Kambatisa", "Psychology",
            "Educational Leadership and Management", "Special Needs and Inclusive Education",
            "Adult and Lifelong Learning", "Law (LLB)", "Veterinary Medicine"
        ];

        // DOM Elements
        const pages = document.querySelectorAll('.page');
        const navLinks = document.querySelectorAll('.nav-link');
        const userMenuBtn = document.getElementById('userMenuBtn');
        const userDropdown = document.getElementById('userDropdown');
        const authButtons = document.getElementById('authButtons');
        const loginBtn = document.getElementById('loginBtn');
        const signupBtn = document.getElementById('signupBtn');
        const logoutBtn = document.getElementById('logoutBtn');
        const goToLogin = document.getElementById('goToLogin');
        const goToSignup = document.getElementById('goToSignup');
        const loginForm = document.getElementById('loginForm');
        const signupForm = document.getElementById('signupForm');
        const contactForm = document.getElementById('contactForm');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const createPostBtn = document.getElementById('createPostBtn');
        const signupDepartment = document.getElementById('signupDepartment');
        const postsContainer = document.getElementById('postsContainer');
        const trendingList = document.getElementById('trendingList');
        const categoryList = document.getElementById('categoryList');
        const profileHeader = document.getElementById('profileHeader');

        // Current user state
        let currentUser = null;

        // Initialize the app
        function initApp() {
            // Populate departments dropdown
            departments.forEach(dept => {
                const option = document.createElement('option');
                option.value = dept;
                option.textContent = dept;
                signupDepartment.appendChild(option);
            });

            // Set up authentication state observer
            auth.onAuthStateChanged(user => {
                if (user) {
                    // User is signed in
                    currentUser = user;
                    showUserMenu();
                    loadUserProfile(user.uid);
                } else {
                    // User is signed out
                    currentUser = null;
                    showAuthButtons();
                }
            });

            // Set up event listeners
            setupEventListeners();

            // Load initial data
            loadPosts();
            loadTrendingTopics();
            loadCategories();
        }

        // Set up all event listeners
        function setupEventListeners() {
            // Navigation
            navLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const pageId = link.getAttribute('data-page');
                    showPage(pageId);
                    
                    // Close dropdown if open
                    userDropdown.classList.remove('show');
                });
            });

            // User menu
            userMenuBtn.addEventListener('click', () => {
                userDropdown.classList.toggle('show');
            });

            // Authentication buttons
            loginBtn.addEventListener('click', () => showPage('login'));
            signupBtn.addEventListener('click', () => showPage('signup'));
            logoutBtn.addEventListener('click', handleLogout);
            goToLogin.addEventListener('click', (e) => {
                e.preventDefault();
                showPage('login');
            });
            goToSignup.addEventListener('click', (e) => {
                e.preventDefault();
                showPage('signup');
            });

            // Forms
            loginForm.addEventListener('submit', handleLogin);
            signupForm.addEventListener('submit', handleSignup);
            contactForm.addEventListener('submit', handleContact);

            // Dark mode toggle
            darkModeToggle.addEventListener('click', toggleDarkMode);

            // Create post button
            createPostBtn.addEventListener('click', () => {
                if (currentUser) {
                    // Show create post modal or page
                    alert('Create post functionality will be implemented');
                } else {
                    showNotification('Please log in to create a post', 'error');
                    showPage('login');
                }
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!userMenuBtn.contains(e.target) && !userDropdown.contains(e.target)) {
                    userDropdown.classList.remove('show');
                }
            });
        }

        // Show specific page
        function showPage(pageId) {
            pages.forEach(page => {
                page.classList.remove('active');
            });
            
            document.getElementById(pageId).classList.add('active');
            
            // Update active nav link
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('data-page') === pageId) {
                    link.classList.add('active');
                }
            });

            // Load page-specific content
            if (pageId === 'profile' && currentUser) {
                loadUserProfile(currentUser.uid);
            }
        }

        // Show user menu when logged in
        function showUserMenu() {
            authButtons.classList.add('hidden');
            userMenuBtn.classList.remove('hidden');
        }

        // Show auth buttons when logged out
        function showAuthButtons() {
            authButtons.classList.remove('hidden');
            userMenuBtn.classList.add('hidden');
            userDropdown.classList.remove('show');
        }

        // Handle user login
        function handleLogin(e) {
            e.preventDefault();
            
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            
            auth.signInWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    // Signed in successfully
                    showNotification('Login successful!', 'success');
                    showPage('home');
                    loginForm.reset();
                })
                .catch((error) => {
                    showNotification(error.message, 'error');
                });
        }

        // Handle user signup
        function handleSignup(e) {
            e.preventDefault();
            
            const fullName = document.getElementById('signupFullName').value;
            const email = document.getElementById('signupEmail').value;
            const password = document.getElementById('signupPassword').value;
            const department = document.getElementById('signupDepartment').value;
            const year = document.getElementById('signupYear').value;
            const studentId = document.getElementById('signupStudentId').value;
            
            auth.createUserWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    // User created successfully
                    const user = userCredential.user;
                    
                    // Save additional user data to Firestore
                    return db.collection('users').doc(user.uid).set({
                        fullName: fullName,
                        email: email,
                        department: department,
                        year: year,
                        studentId: studentId,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                })
                .then(() => {
                    showNotification('Account created successfully!', 'success');
                    showPage('profile');
                    signupForm.reset();
                })
                .catch((error) => {
                    showNotification(error.message, 'error');
                });
        }

        // Handle user logout
        function handleLogout() {
            auth.signOut()
                .then(() => {
                    showNotification('Logged out successfully', 'success');
                    showPage('home');
                })
                .catch((error) => {
                    showNotification(error.message, 'error');
                });
        }

        // Handle contact form submission
        function handleContact(e) {
            e.preventDefault();
            
            const name = document.getElementById('contactName').value;
            const email = document.getElementById('contactEmail').value;
            const subject = document.getElementById('contactSubject').value;
            const message = document.getElementById('contactMessage').value;
            
            // Save contact message to Firestore
            db.collection('contacts').add({
                name: name,
                email: email,
                subject: subject,
                message: message,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            })
            .then(() => {
                showNotification('Message sent successfully!', 'success');
                contactForm.reset();
            })
            .catch((error) => {
                showNotification('Error sending message: ' + error.message, 'error');
            });
        }

        // Load user profile data
        function loadUserProfile(userId) {
            db.collection('users').doc(userId).get()
                .then((doc) => {
                    if (doc.exists) {
                        const userData = doc.data();
                        document.getElementById('userName').textContent = userData.fullName;
                        
                        // Update profile page if it's active
                        if (document.getElementById('profile').classList.contains('active')) {
                            updateProfilePage(userData);
                        }
                    }
                })
                .catch((error) => {
                    console.error('Error loading user profile:', error);
                });
        }

        // Update profile page with user data
        function updateProfilePage(userData) {
            profileHeader.innerHTML = `
                <div class="profile-avatar">${userData.fullName.split(' ').map(n => n[0]).join('')}</div>
                <div class="profile-info">
                    <h2>${userData.fullName}</h2>
                    <p>${userData.department}, Year ${userData.year}</p>
                    <p>Student ID: ${userData.studentId}</p>
                    <div class="profile-stats">
                        <div class="stat">
                            <div class="stat-value">0</div>
                            <div class="stat-label">Posts</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">0</div>
                            <div class="stat-label">Likes</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">0</div>
                            <div class="stat-label">Comments</div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Load posts from Firestore
        function loadPosts() {
            // This would load posts from Firestore
            // For now, we'll keep it empty as per requirement
            postsContainer.innerHTML = '';
        }

        // Load trending topics
        function loadTrendingTopics() {
            // This would load trending topics from Firestore
            // For now, we'll keep it empty as per requirement
            trendingList.innerHTML = '';
        }

        // Load categories
        function loadCategories() {
            // This would load categories from Firestore
            // For now, we'll keep it empty as per requirement
            categoryList.innerHTML = '';
        }

        // Toggle dark mode
        function toggleDarkMode() {
            const body = document.body;
            const isDarkMode = body.getAttribute('data-theme') === 'dark';
            
            if (isDarkMode) {
                body.removeAttribute('data-theme');
                darkModeToggle.innerHTML = '<i class="fas fa-moon"></i>';
                localStorage.setItem('theme', 'light');
            } else {
                body.setAttribute('data-theme', 'dark');
                darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
                localStorage.setItem('theme', 'dark');
            }
        }

        // Show notification
        function showNotification(message, type) {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notification => {
                notification.remove();
            });
            
            // Create new notification
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Check for saved theme preference
        function checkSavedTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                document.body.setAttribute('data-theme', 'dark');
                darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
            }
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            checkSavedTheme();
            initApp();
        });
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
// ===============================
// WCUVoice Social Features Implementation
// Setup Instructions:
// 1. Enable Firebase Storage in your Firebase Console
// 2. Deploy Cloud Functions: firebase deploy --only functions
// 3. Update Firestore rules with the provided security rules
// 4. Add this code to your existing WCUVoice project
// ===============================

// Firestore Data Model:
// - posts/{postId}: { title, content, authorId, authorName, createdAt, imageUrl, likesCount, dislikesCount, commentsCount }
// - comments/{commentId}: { postId, parentCommentId (for replies), content, authorId, authorName, createdAt, likesCount, dislikesCount }
// - reactions/{reactionId}: { targetType: 'post'|'comment', targetId, userId, type: 'like'|'dislike', createdAt }
// - notifications/{notificationId}: { userId, type: 'comment'|'reply'|'like', sourceUserId, sourceUserName, targetId, targetType, message, read, createdAt }

// Firestore Security Rules (replace your current rules):
/*
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users can read/write their own profile
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Posts: anyone can read, only auth users can create, only owner can update/delete
    match /posts/{postId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.authorId;
      allow update, delete: if request.auth != null 
        && request.auth.uid == resource.data.authorId;
    }
    
    // Comments: similar to posts
    match /comments/{commentId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.authorId;
      allow update, delete: if request.auth != null 
        && request.auth.uid == resource.data.authorId;
    }
    
    // Reactions: users can manage their own reactions
    match /reactions/{reactionId} {
      allow read: if request.auth != null;
      allow create, update, delete: if request.auth != null 
        && request.auth.uid == request.resource.data.userId;
    }
    
    // Notifications: users can only access their own
    match /notifications/{notificationId} {
      allow read, write: if request.auth != null 
        && request.auth.uid == resource.data.userId;
    }
  }
}
*/

// Cloud Functions (Firebase) - Add to functions/index.js:
/*
const functions = require('firebase-functions');
const admin = require('firebase-admin');
admin.initializeApp();

exports.createNotification = functions.firestore
  .document('{collection}/{docId}')
  .onCreate(async (snapshot, context) => {
    const data = snapshot.data();
    const { collection } = context.params;
    
    if (collection === 'comments') {
      // Notification for post owner when someone comments
      const postRef = admin.firestore().collection('posts').doc(data.postId);
      const post = await postRef.get();
      
      if (post.exists && data.authorId !== post.data().authorId) {
        await admin.firestore().collection('notifications').add({
          userId: post.data().authorId,
          type: 'comment',
          sourceUserId: data.authorId,
          sourceUserName: data.authorName,
          targetId: data.postId,
          targetType: 'post',
          message: `${data.authorName} commented on your post`,
          read: false,
          createdAt: admin.firestore.FieldValue.serverTimestamp()
        });
      }
      
      // Notification for comment owner when someone replies
      if (data.parentCommentId) {
        const parentCommentRef = admin.firestore().collection('comments').doc(data.parentCommentId);
        const parentComment = await parentCommentRef.get();
        
        if (parentComment.exists && data.authorId !== parentComment.data().authorId) {
          await admin.firestore().collection('notifications').add({
            userId: parentComment.data().authorId,
            type: 'reply',
            sourceUserId: data.authorId,
            sourceUserName: data.authorName,
            targetId: data.parentCommentId,
            targetType: 'comment',
            message: `${data.authorName} replied to your comment`,
            read: false,
            createdAt: admin.firestore.FieldValue.serverTimestamp()
          });
        }
      }
    }
    
    if (collection === 'reactions') {
      const { targetType, targetId, userId, type } = data;
      
      let targetRef, targetOwnerField;
      if (targetType === 'post') {
        targetRef = admin.firestore().collection('posts').doc(targetId);
        targetOwnerField = 'authorId';
      } else {
        targetRef = admin.firestore().collection('comments').doc(targetId);
        targetOwnerField = 'authorId';
      }
      
      const target = await targetRef.get();
      if (target.exists) {
        const targetOwnerId = target.data()[targetOwnerField];
        if (targetOwnerId !== userId) {
          await admin.firestore().collection('notifications').add({
            userId: targetOwnerId,
            type: 'like',
            sourceUserId: userId,
            sourceUserName: data.userName || 'Someone',
            targetId: targetId,
            targetType: targetType,
            message: `${data.userName || 'Someone'} ${type}d your ${targetType}`,
            read: false,
            createdAt: admin.firestore.FieldValue.serverTimestamp()
          });
        }
      }
    }
    
    return null;
  });

exports.updateCounters = functions.firestore
  .document('{collection}/{docId}')
  .onWrite(async (change, context) => {
    const { collection, docId } = context.params;
    
    if (collection === 'comments') {
      const postId = change.after.exists ? change.after.data().postId : change.before.data().postId;
      const commentsSnapshot = await admin.firestore().collection('comments')
        .where('postId', '==', postId)
        .get();
      
      await admin.firestore().collection('posts').doc(postId).update({
        commentsCount: commentsSnapshot.size
      });
    }
    
    if (collection === 'reactions') {
      const data = change.after.exists ? change.after.data() : change.before.data();
      const { targetType, targetId } = data;
      
      const likesSnapshot = await admin.firestore().collection('reactions')
        .where('targetType', '==', targetType)
        .where('targetId', '==', targetId)
        .where('type', '==', 'like')
        .get();
      
      const dislikesSnapshot = await admin.firestore().collection('reactions')
        .where('targetType', '==', targetType)
        .where('targetId', '==', targetId)
        .where('type', '==', 'dislike')
        .get();
      
      const updateData = {
        likesCount: likesSnapshot.size,
        dislikesCount: dislikesSnapshot.size
      };
      
      const targetRef = targetType === 'post' 
        ? admin.firestore().collection('posts').doc(targetId)
        : admin.firestore().collection('comments').doc(targetId);
      
      await targetRef.update(updateData);
    }
    
    return null;
  });
*/

// Frontend Implementation - Add to your existing JavaScript:

// Social Features Manager
class SocialFeatures {
  constructor() {
    this.currentUser = null;
    this.postsListener = null;
    this.notificationsListener = null;
  }

  init() {
    auth.onAuthStateChanged(user => {
      this.currentUser = user;
      if (user) {
        this.loadUserProfile(user.uid);
        this.setupRealTimeListeners();
        this.setupNotifications();
      } else {
        this.cleanupListeners();
      }
    });
    
    this.setupEventListeners();
  }

  setupEventListeners() {
    // Replace existing createPostBtn event listener
    document.getElementById('createPostBtn').addEventListener('click', () => {
      this.showCreatePostModal();
    });
    
    // Add notifications bell if not exists
    if (!document.getElementById('notificationsBell')) {
      this.createNotificationsUI();
    }
  }

  createNotificationsUI() {
    const userMenu = document.querySelector('.user-menu');
    const notificationsHTML = `
      <div class="notifications-container">
        <button class="notifications-btn" id="notificationsBell">
          <i class="fas fa-bell"></i>
          <span class="notification-count hidden" id="notificationCount">0</span>
        </button>
        <div class="notifications-dropdown hidden" id="notificationsDropdown">
          <div class="notifications-header">
            <h4>Notifications</h4>
            <button class="mark-all-read" id="markAllRead">Mark all read</button>
          </div>
          <div class="notifications-list" id="notificationsList"></div>
        </div>
      </div>
    `;
    userMenu.insertAdjacentHTML('afterbegin', notificationsHTML);
    
    // Notifications event listeners
    document.getElementById('notificationsBell').addEventListener('click', (e) => {
      e.stopPropagation();
      this.toggleNotificationsDropdown();
    });
    
    document.getElementById('markAllRead').addEventListener('click', () => {
      this.markAllNotificationsRead();
    });
    
    document.addEventListener('click', () => {
      document.getElementById('notificationsDropdown').classList.add('hidden');
    });
  }

  showCreatePostModal() {
    if (!this.currentUser) {
      showNotification('Please log in to create a post', 'error');
      showPage('login');
      return;
    }

    const modalHTML = `
      <div class="modal-overlay" id="createPostModal">
        <div class="modal-content">
          <div class="modal-header">
            <h3>Create New Post</h3>
            <button class="close-modal">&times;</button>
          </div>
          <form id="createPostForm">
            <div class="form-group">
              <label for="postTitle">Title</label>
              <input type="text" id="postTitle" class="form-control" required maxlength="200">
            </div>
            <div class="form-group">
              <label for="postContent">Content</label>
              <textarea id="postContent" class="form-control" rows="6" required maxlength="2000"></textarea>
            </div>
            <div class="form-group">
              <label for="postImage">Image (optional)</label>
              <input type="file" id="postImage" accept="image/*">
              <div class="image-preview hidden" id="imagePreview"></div>
            </div>
            <div class="form-actions">
              <button type="button" class="btn btn-secondary" id="cancelPost">Cancel</button>
              <button type="submit" class="btn btn-primary">Create Post</button>
            </div>
          </form>
        </div>
      </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    const modal = document.getElementById('createPostModal');
    const form = document.getElementById('createPostForm');
    const imageInput = document.getElementById('postImage');
    const imagePreview = document.getElementById('imagePreview');
    
    // Event listeners for modal
    document.querySelector('.close-modal').addEventListener('click', () => this.closeModal(modal));
    document.getElementById('cancelPost').addEventListener('click', () => this.closeModal(modal));
    modal.addEventListener('click', (e) => {
      if (e.target === modal) this.closeModal(modal);
    });
    
    imageInput.addEventListener('change', (e) => {
      this.handleImagePreview(e, imagePreview);
    });
    
    form.addEventListener('submit', (e) => this.handleCreatePost(e, modal));
  }

  async handleCreatePost(e, modal) {
    e.preventDefault();
    
    const title = document.getElementById('postTitle').value;
    const content = document.getElementById('postContent').value;
    const imageFile = document.getElementById('postImage').files[0];
    
    try {
      let imageUrl = '';
      
      if (imageFile) {
        imageUrl = await this.uploadImage(imageFile);
      }
      
      const postData = {
        title,
        content,
        authorId: this.currentUser.uid,
        authorName: this.currentUser.displayName || 'Anonymous',
        imageUrl,
        likesCount: 0,
        dislikesCount: 0,
        commentsCount: 0,
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      
      await db.collection('posts').add(postData);
      
      showNotification('Post created successfully!', 'success');
      this.closeModal(modal);
      
    } catch (error) {
      showNotification('Error creating post: ' + error.message, 'error');
    }
  }

  async uploadImage(file) {
    const storageRef = firebase.storage().ref();
    const imageRef = storageRef.child(`posts/${Date.now()}_${file.name}`);
    const snapshot = await imageRef.put(file);
    return await snapshot.ref.getDownloadURL();
  }

  handleImagePreview(event, previewElement) {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        previewElement.innerHTML = `<img src="${e.target.result}" alt="Preview">`;
        previewElement.classList.remove('hidden');
      };
      reader.readAsDataURL(file);
    }
  }

  closeModal(modal) {
    modal.remove();
  }

  setupRealTimeListeners() {
    // Listen for new posts
    this.postsListener = db.collection('posts')
      .orderBy('createdAt', 'desc')
      .limit(20)
      .onSnapshot(snapshot => {
        this.renderPosts(snapshot.docs);
      }, error => {
        console.error('Posts listener error:', error);
      });
  }

  renderPosts(postDocs) {
    const postsContainer = document.getElementById('postsContainer');
    postsContainer.innerHTML = '';
    
    postDocs.forEach(doc => {
      const post = doc.data();
      const postElement = this.createPostElement(post, doc.id);
      postsContainer.appendChild(postElement);
    });
  }

  createPostElement(post, postId) {
    const postElement = document.createElement('div');
    postElement.className = 'post-card';
    postElement.innerHTML = `
      <div class="post-header">
        <div class="post-author">
          <div class="avatar">${post.authorName.charAt(0).toUpperCase()}</div>
          <div>
            <div class="author-name">${post.authorName}</div>
            <div class="post-time">${this.formatTime(post.createdAt)}</div>
          </div>
        </div>
        ${this.currentUser.uid === post.authorId ? `
          <div class="post-actions-menu">
            <button class="action-menu-btn"><i class="fas fa-ellipsis-h"></i></button>
            <div class="action-menu hidden">
              <button class="edit-post" data-post-id="${postId}">Edit</button>
              <button class="delete-post" data-post-id="${postId}">Delete</button>
            </div>
          </div>
        ` : ''}
      </div>
      <h3 class="post-title">${post.title}</h3>
      <div class="post-content">${post.content}</div>
      ${post.imageUrl ? `<div class="post-image"><img src="${post.imageUrl}" alt="Post image"></div>` : ''}
      <div class="post-stats">
        <span class="likes-count">${post.likesCount} likes</span>
        <span class="comments-count">${post.commentsCount} comments</span>
      </div>
      <div class="post-actions">
        <button class="action-btn like-btn ${this.getUserReactionClass('post', postId)}" data-target-type="post" data-target-id="${postId}">
          <i class="fas fa-thumbs-up"></i> Like
        </button>
        <button class="action-btn dislike-btn ${this.getUserReactionClass('post', postId, 'dislike')}" data-target-type="post" data-target-id="${postId}">
          <i class="fas fa-thumbs-down"></i> Dislike
        </button>
        <button class="action-btn comment-btn" data-post-id="${postId}">
          <i class="fas fa-comment"></i> Comment
        </button>
      </div>
      <div class="comments-section hidden" id="comments-${postId}">
        <div class="comment-form">
          <textarea class="comment-input" placeholder="Write a comment..." rows="2"></textarea>
          <button class="btn btn-primary post-comment" data-post-id="${postId}">Post</button>
        </div>
        <div class="comments-list" id="comments-list-${postId}"></div>
      </div>
    `;
    
    this.attachPostEventListeners(postElement, postId);
    return postElement;
  }

  attachPostEventListeners(postElement, postId) {
    // Like/Dislike buttons
    postElement.querySelectorAll('.like-btn, .dislike-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        this.handleReaction(e.target.closest('button'));
      });
    });
    
    // Comment button
    postElement.querySelector('.comment-btn').addEventListener('click', () => {
      this.toggleCommentsSection(postId);
    });
    
    // Post comment button
    postElement.querySelector('.post-comment').addEventListener('click', () => {
      this.postComment(postId);
    });
    
    // Action menu for post owner
    const actionMenuBtn = postElement.querySelector('.action-menu-btn');
    if (actionMenuBtn) {
      actionMenuBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const menu = postElement.querySelector('.action-menu');
        menu.classList.toggle('hidden');
      });
      
      postElement.querySelector('.edit-post').addEventListener('click', () => {
        this.editPost(postId);
      });
      
      postElement.querySelector('.delete-post').addEventListener('click', () => {
        this.deletePost(postId);
      });
    }
    
    // Close action menu when clicking outside
    document.addEventListener('click', () => {
      const menus = document.querySelectorAll('.action-menu');
      menus.forEach(menu => menu.classList.add('hidden'));
    });
  }

  async handleReaction(button) {
    if (!this.currentUser) {
      showNotification('Please log in to react', 'error');
      return;
    }
    
    const targetType = button.dataset.targetType;
    const targetId = button.dataset.targetId;
    const isLike = button.classList.contains('like-btn');
    const reactionType = isLike ? 'like' : 'dislike';
    
    try {
      // Check if user already reacted
      const existingReaction = await db.collection('reactions')
        .where('userId', '==', this.currentUser.uid)
        .where('targetType', '==', targetType)
        .where('targetId', '==', targetId)
        .get();
      
      if (!existingReaction.empty) {
        const existing = existingReaction.docs[0];
        const existingData = existing.data();
        
        if (existingData.type === reactionType) {
          // Remove reaction if same type clicked
          await existing.ref.delete();
        } else {
          // Update reaction if different type
          await existing.ref.update({ type: reactionType });
        }
      } else {
        // Create new reaction
        await db.collection('reactions').add({
          targetType,
          targetId,
          userId: this.currentUser.uid,
          userName: this.currentUser.displayName || 'Anonymous',
          type: reactionType,
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
      }
    } catch (error) {
      showNotification('Error updating reaction: ' + error.message, 'error');
    }
  }

  getUserReactionClass(targetType, targetId, checkType = 'like') {
    // This would be implemented with real-time listener for user's reactions
    return ''; // Placeholder - implement based on user's current reaction state
  }

  async toggleCommentsSection(postId) {
    const commentsSection = document.getElementById(`comments-${postId}`);
    const commentsList = document.getElementById(`comments-list-${postId}`);
    
    if (commentsSection.classList.contains('hidden')) {
      commentsSection.classList.remove('hidden');
      await this.loadComments(postId, commentsList);
      
      // Set up real-time listener for comments
      this.setupCommentsListener(postId, commentsList);
    } else {
      commentsSection.classList.add('hidden');
    }
  }

  async loadComments(postId, commentsList) {
    const comments = await db.collection('comments')
      .where('postId', '==', postId)
      .where('parentCommentId', '==', null)
      .orderBy('createdAt', 'asc')
      .get();
    
    commentsList.innerHTML = '';
    comments.docs.forEach(doc => {
      const commentElement = this.createCommentElement(doc.data(), doc.id);
      commentsList.appendChild(commentElement);
    });
  }

  setupCommentsListener(postId, commentsList) {
    return db.collection('comments')
      .where('postId', '==', postId)
      .where('parentCommentId', '==', null)
      .orderBy('createdAt', 'asc')
      .onSnapshot(snapshot => {
        commentsList.innerHTML = '';
        snapshot.docs.forEach(doc => {
          const commentElement = this.createCommentElement(doc.data(), doc.id);
          commentsList.appendChild(commentElement);
        });
      });
  }

  createCommentElement(comment, commentId) {
    const commentElement = document.createElement('div');
    commentElement.className = 'comment';
    commentElement.innerHTML = `
      <div class="comment-header">
        <div class="comment-author">
          <div class="avatar small">${comment.authorName.charAt(0).toUpperCase()}</div>
          <span class="author-name">${comment.authorName}</span>
          <span class="comment-time">${this.formatTime(comment.createdAt)}</span>
        </div>
        ${this.currentUser.uid === comment.authorId ? `
          <div class="comment-actions">
            <button class="edit-comment" data-comment-id="${commentId}">Edit</button>
            <button class="delete-comment" data-comment-id="${commentId}">Delete</button>
          </div>
        ` : ''}
      </div>
      <div class="comment-content">${comment.content}</div>
      <div class="comment-actions-bar">
        <button class="action-btn like-btn ${this.getUserReactionClass('comment', commentId)}" data-target-type="comment" data-target-id="${commentId}">
          <i class="fas fa-thumbs-up"></i> ${comment.likesCount || 0}
        </button>
        <button class="action-btn dislike-btn ${this.getUserReactionClass('comment', commentId, 'dislike')}" data-target-type="comment" data-target-id="${commentId}">
          <i class="fas fa-thumbs-down"></i> ${comment.dislikesCount || 0}
        </button>
        <button class="action-btn reply-btn" data-comment-id="${commentId}">Reply</button>
      </div>
      <div class="replies-section hidden" id="replies-${commentId}">
        <div class="reply-form">
          <textarea class="reply-input" placeholder="Write a reply..." rows="1"></textarea>
          <button class="btn btn-primary post-reply" data-comment-id="${commentId}">Reply</button>
        </div>
        <div class="replies-list" id="replies-list-${commentId}"></div>
      </div>
    `;
    
    this.attachCommentEventListeners(commentElement, commentId);
    return commentElement;
  }

  attachCommentEventListeners(commentElement, commentId) {
    // Like/Dislike buttons
    commentElement.querySelectorAll('.like-btn, .dislike-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        this.handleReaction(e.target.closest('button'));
      });
    });
    
    // Reply button
    commentElement.querySelector('.reply-btn').addEventListener('click', () => {
      this.toggleRepliesSection(commentId);
    });
    
    // Post reply button
    commentElement.querySelector('.post-reply').addEventListener('click', () => {
      this.postReply(commentId);
    });
    
    // Edit/Delete buttons for comment owner
    const editBtn = commentElement.querySelector('.edit-comment');
    const deleteBtn = commentElement.querySelector('.delete-comment');
    
    if (editBtn) {
      editBtn.addEventListener('click', () => this.editComment(commentId));
    }
    if (deleteBtn) {
      deleteBtn.addEventListener('click', () => this.deleteComment(commentId));
    }
  }

  async postComment(postId) {
    if (!this.currentUser) {
      showNotification('Please log in to comment', 'error');
      return;
    }
    
    const commentInput = document.querySelector(`#comments-${postId} .comment-input`);
    const content = commentInput.value.trim();
    
    if (!content) {
      showNotification('Please enter a comment', 'error');
      return;
    }
    
    try {
      await db.collection('comments').add({
        postId,
        content,
        authorId: this.currentUser.uid,
        authorName: this.currentUser.displayName || 'Anonymous',
        parentCommentId: null,
        likesCount: 0,
        dislikesCount: 0,
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      });
      
      commentInput.value = '';
      showNotification('Comment posted!', 'success');
    } catch (error) {
      showNotification('Error posting comment: ' + error.message, 'error');
    }
  }

  async postReply(parentCommentId) {
    if (!this.currentUser) {
      showNotification('Please log in to reply', 'error');
      return;
    }
    
    const replyInput = document.querySelector(`#replies-${parentCommentId} .reply-input`);
    const content = replyInput.value.trim();
    
    if (!content) {
      showNotification('Please enter a reply', 'error');
      return;
    }
    
    try {
      // Get postId from parent comment
      const parentComment = await db.collection('comments').doc(parentCommentId).get();
      const postId = parentComment.data().postId;
      
      await db.collection('comments').add({
        postId,
        content,
        authorId: this.currentUser.uid,
        authorName: this.currentUser.displayName || 'Anonymous',
        parentCommentId,
        likesCount: 0,
        dislikesCount: 0,
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      });
      
      replyInput.value = '';
      showNotification('Reply posted!', 'success');
    } catch (error) {
      showNotification('Error posting reply: ' + error.message, 'error');
    }
  }

  async toggleRepliesSection(commentId) {
    const repliesSection = document.getElementById(`replies-${commentId}`);
    const repliesList = document.getElementById(`replies-list-${commentId}`);
    
    if (repliesSection.classList.contains('hidden')) {
      repliesSection.classList.remove('hidden');
      await this.loadReplies(commentId, repliesList);
    } else {
      repliesSection.classList.add('hidden');
    }
  }

  async loadReplies(commentId, repliesList) {
    const replies = await db.collection('comments')
      .where('parentCommentId', '==', commentId)
      .orderBy('createdAt', 'asc')
      .get();
    
    repliesList.innerHTML = '';
    replies.docs.forEach(doc => {
      const replyElement = this.createCommentElement(doc.data(), doc.id);
      repliesList.appendChild(replyElement);
    });
  }

  setupNotifications() {
    if (!this.currentUser) return;
    
    this.notificationsListener = db.collection('notifications')
      .where('userId', '==', this.currentUser.uid)
      .orderBy('createdAt', 'desc')
      .limit(20)
      .onSnapshot(snapshot => {
        this.updateNotificationsUI(snapshot.docs);
      });
  }

  updateNotificationsUI(notificationDocs) {
    const notificationsList = document.getElementById('notificationsList');
    const notificationCount = document.getElementById('notificationCount');
    
    const unreadCount = notificationDocs.filter(doc => !doc.data().read).length;
    
    if (unreadCount > 0) {
      notificationCount.textContent = unreadCount > 99 ? '99+' : unreadCount;
      notificationCount.classList.remove('hidden');
    } else {
      notificationCount.classList.add('hidden');
    }
    
    notificationsList.innerHTML = '';
    
    notificationDocs.forEach(doc => {
      const notification = doc.data();
      const notificationElement = this.createNotificationElement(notification, doc.id);
      notificationsList.appendChild(notificationElement);
    });
  }

  createNotificationElement(notification, notificationId) {
    const element = document.createElement('div');
    element.className = `notification-item ${notification.read ? 'read' : 'unread'}`;
    element.innerHTML = `
      <div class="notification-content">
        <div class="notification-message">${notification.message}</div>
        <div class="notification-time">${this.formatTime(notification.createdAt)}</div>
      </div>
      ${!notification.read ? `<button class="mark-read" data-notification-id="${notificationId}"><i class="fas fa-check"></i></button>` : ''}
    `;
    
    if (!notification.read) {
      element.querySelector('.mark-read').addEventListener('click', (e) => {
        e.stopPropagation();
        this.markNotificationRead(notificationId);
      });
    }
    
    element.addEventListener('click', () => {
      this.handleNotificationClick(notification);
    });
    
    return element;
  }

  async markNotificationRead(notificationId) {
    await db.collection('notifications').doc(notificationId).update({
      read: true
    });
  }

  async markAllNotificationsRead() {
    const unreadNotifications = await db.collection('notifications')
      .where('userId', '==', this.currentUser.uid)
      .where('read', '==', false)
      .get();
    
    const batch = db.batch();
    unreadNotifications.docs.forEach(doc => {
      batch.update(doc.ref, { read: true });
    });
    
    await batch.commit();
  }

  handleNotificationClick(notification) {
    // Navigate to the relevant post/comment
    if (notification.targetType === 'post') {
      this.scrollToPost(notification.targetId);
    }
    this.markNotificationRead(notification.id);
  }

  toggleNotificationsDropdown() {
    const dropdown = document.getElementById('notificationsDropdown');
    dropdown.classList.toggle('hidden');
  }

  scrollToPost(postId) {
    const postElement = document.querySelector(`[data-post-id="${postId}"]`);
    if (postElement) {
      postElement.scrollIntoView({ behavior: 'smooth' });
      this.toggleCommentsSection(postId);
    }
  }

  async editPost(postId) {
    // Implementation for editing posts
    showNotification('Edit post functionality coming soon', 'info');
  }

  async deletePost(postId) {
    if (confirm('Are you sure you want to delete this post?')) {
      try {
        await db.collection('posts').doc(postId).delete();
        showNotification('Post deleted', 'success');
      } catch (error) {
        showNotification('Error deleting post: ' + error.message, 'error');
      }
    }
  }

  async editComment(commentId) {
    // Implementation for editing comments
    showNotification('Edit comment functionality coming soon', 'info');
  }

  async deleteComment(commentId) {
    if (confirm('Are you sure you want to delete this comment?')) {
      try {
        await db.collection('comments').doc(commentId).delete();
        showNotification('Comment deleted', 'success');
      } catch (error) {
        showNotification('Error deleting comment: ' + error.message, 'error');
      }
    }
  }

  formatTime(timestamp) {
    if (!timestamp) return '';
    const date = timestamp.toDate();
    const now = new Date();
    const diff = now - date;
    
    const minute = 60 * 1000;
    const hour = minute * 60;
    const day = hour * 24;
    
    if (diff < minute) return 'Just now';
    if (diff < hour) return `${Math.floor(diff / minute)}m ago`;
    if (diff < day) return `${Math.floor(diff / hour)}h ago`;
    if (diff < day * 7) return `${Math.floor(diff / day)}d ago`;
    
    return date.toLocaleDateString();
  }

  loadUserProfile(userId) {
    // Load user profile for display
    db.collection('users').doc(userId).get()
      .then(doc => {
        if (doc.exists) {
          const userData = doc.data();
          // Update UI with user data if needed
        }
      })
      .catch(error => {
        console.error('Error loading user profile:', error);
      });
  }

  cleanupListeners() {
    if (this.postsListener) {
      this.postsListener();
    }
    if (this.notificationsListener) {
      this.notificationsListener();
    }
  }
}

// Add CSS for new components
const socialCSS = `
/* Social Features CSS */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  border-radius: 8px;
  padding: 20px;
  width: 90%;
  max-width: 600px;
  max-height: 90vh;
  overflow-y: auto;
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.close-modal {
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
}

.form-actions {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  margin-top: 20px;
}

.image-preview img {
  max-width: 100%;
  max-height: 200px;
  border-radius: 4px;
  margin-top: 10px;
}

/* Notifications */
.notifications-container {
  position: relative;
  margin-right: 15px;
}

.notifications-btn {
  background: none;
  border: none;
  color: white;
  font-size: 1.2rem;
  position: relative;
  cursor: pointer;
}

.notification-count {
  position: absolute;
  top: -5px;
  right: -5px;
  background: var(--accent);
  color: white;
  border-radius: 50%;
  width: 18px;
  height: 18px;
  font-size: 0.7rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

.notifications-dropdown {
  position: absolute;
  top: 100%;
  right: 0;
  background: white;
  border-radius: 4px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  width: 350px;
  max-height: 400px;
  overflow-y: auto;
  z-index: 100;
}

.notifications-header {
  padding: 15px;
  border-bottom: 1px solid #eee;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.notifications-list {
  max-height: 300px;
  overflow-y: auto;
}

.notification-item {
  padding: 12px 15px;
  border-bottom: 1px solid #f5f5f5;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.notification-item.unread {
  background: #f8f9fa;
}

.notification-item:hover {
  background: #f0f0f0;
}

.notification-content {
  flex: 1;
}

.notification-message {
  font-weight: 500;
  margin-bottom: 4px;
}

.notification-time {
  font-size: 0.8rem;
  color: var(--gray);
}

.mark-read {
  background: none;
  border: none;
  color: var(--secondary);
  cursor: pointer;
}

.mark-all-read {
  background: none;
  border: none;
  color: var(--secondary);
  cursor: pointer;
  font-size: 0.8rem;
}

/* Posts and Comments */
.post-stats {
  display: flex;
  gap: 15px;
  margin: 10px 0;
  font-size: 0.9rem;
  color: var(--gray);
}

.post-actions {
  display: flex;
  gap: 15px;
  border-top: 1px solid #eee;
  padding-top: 10px;
}

.action-btn {
  background: none;
  border: none;
  color: var(--gray);
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 5px 10px;
  border-radius: 4px;
}

.action-btn:hover {
  background: #f5f5f5;
}

.action-btn.active {
  color: var(--secondary);
}

.like-btn.active {
  color: #1877f2;
}

.dislike-btn.active {
  color: #ff4444;
}

.post-actions-menu {
  position: relative;
}

.action-menu-btn {
  background: none;
  border: none;
  color: var(--gray);
  cursor: pointer;
  padding: 5px;
}

.action-menu {
  position: absolute;
  top: 100%;
  right: 0;
  background: white;
  border-radius: 4px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  min-width: 120px;
  z-index: 10;
}

.action-menu button {
  display: block;
  width: 100%;
  padding: 8px 12px;
  background: none;
  border: none;
  text-align: left;
  cursor: pointer;
}

.action-menu button:hover {
  background: #f5f5f5;
}

/* Comments */
.comments-section {
  margin-top: 15px;
  border-top: 1px solid #eee;
  padding-top: 15px;
}

.comment-form, .reply-form {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
}

.comment-input, .reply-input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 20px;
  resize: vertical;
}

.comment {
  margin-bottom: 15px;
  padding: 12px;
  background: #f8f9fa;
  border-radius: 8px;
}

.comment-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.comment-author {
  display: flex;
  align-items: center;
  gap: 8px;
}

.avatar.small {
  width: 24px;
  height: 24px;
  font-size: 0.8rem;
}

.author-name {
  font-weight: 600;
  font-size: 0.9rem;
}

.comment-time {
  font-size: 0.8rem;
  color: var(--gray);
}

.comment-actions {
  display: flex;
  gap: 8px;
}

.comment-actions button {
  background: none;
  border: none;
  color: var(--secondary);
  font-size: 0.8rem;
  cursor: pointer;
}

.comment-content {
  margin-bottom: 8px;
  line-height: 1.4;
}

.comment-actions-bar {
  display: flex;
  gap: 15px;
}

.replies-section {
  margin-top: 10px;
  padding-left: 20px;
  border-left: 2px solid #e0e0e0;
}

.reply-form {
  margin: 10px 0;
}

.post-image img {
  max-width: 100%;
  max-height: 400px;
  border-radius: 8px;
  margin: 10px 0;
}
`;

// Add CSS to document
const styleSheet = document.createElement('style');
styleSheet.textContent = socialCSS;
document.head.appendChild(styleSheet);

// Initialize social features when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  // Initialize Firebase Storage if not already initialized
  if (!firebase.apps[0].storage) {
    firebase.initializeApp(firebaseConfig);
  }
  
  const socialFeatures = new SocialFeatures();
  socialFeatures.init();
  
  // Make it globally available for debugging
  window.socialFeatures = socialFeatures;
});

// Manual Test Checklist:
/*
1.  Sign in with a test user
2.  Create a new post with text only
3.  Create a post with image upload
4.  Like/dislike a post (toggle behavior)
5.  Add a comment to a post
6.  Reply to a comment (nested replies)
7.  Like/dislike comments
8.  Edit/delete own posts
9.  Edit/delete own comments
10.  Check notifications for comments/replies/likes
11.  Mark notifications as read
12.  Real-time updates (open two browser windows)
13.  Authentication enforcement (try actions while signed out)
14.  Permission checks (try editing others' posts/comments)
*/

// Utility Functions for Testing:
window.testSocialFeatures = {
  createTestPost: async () => {
    const social = window.socialFeatures;
    if (!social.currentUser) {
      alert('Please sign in first');
      return;
    }
    
    await db.collection('posts').add({
      title: 'Test Post',
      content: 'This is a test post created for testing purposes.',
      authorId: social.currentUser.uid,
      authorName: social.currentUser.displayName || 'Test User',
      likesCount: 0,
      dislikesCount: 0,
      commentsCount: 0,
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    });
    
    alert('Test post created!');
  },
  
  clearTestData: async () => {
    // Warning: This will delete all posts, comments, and reactions
    if (!confirm('This will delete ALL social data. Continue?')) return;
    
    const collections = ['posts', 'comments', 'reactions', 'notifications'];
    
    for (const collection of collections) {
      const snapshot = await db.collection(collection).get();
      const batch = db.batch();
      snapshot.docs.forEach(doc => batch.delete(doc.ref));
      await batch.commit();
    }
    
    alert('All social data cleared!');
  }
};
        
        
        
        
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     // ===============================
// Trending Topics & Categories Implementation
// ===============================

// Add this CSS for trending topics and categories
const trendingCategoriesCSS = `
/* Trending & Categories Styles */
.trending-item, .category-item {
    padding: 8px 0;
    border-bottom: 1px solid #f5f5f5;
    cursor: pointer;
    transition: all 0.3s ease;
}

.trending-item:last-child, .category-item:last-child {
    border-bottom: none;
}

.trending-item:hover, .category-item:hover {
    background-color: #f8f9fa;
    padding-left: 5px;
}

.trending-rank {
    display: inline-block;
    width: 20px;
    height: 20px;
    background: var(--secondary);
    color: white;
    border-radius: 50%;
    text-align: center;
    line-height: 20px;
    font-size: 0.8rem;
    margin-right: 8px;
}

.trending-rank.top-1 { background: #ff6b6b; }
.trending-rank.top-2 { background: #4ecdc4; }
.trending-rank.top-3 { background: #45b7d1; }

.trending-text {
    font-weight: 500;
    font-size: 0.9rem;
}

.trending-count {
    font-size: 0.8rem;
    color: var(--gray);
    margin-left: 5px;
}

.category-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.category-name {
    font-weight: 500;
}

.category-count {
    background: var(--secondary);
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.7rem;
}

.loading-spinner {
    text-align: center;
    padding: 20px;
    color: var(--gray);
}

.empty-state {
    text-align: center;
    padding: 20px;
    color: var(--gray);
    font-style: italic;
}
`;

// Add the CSS to document
const trendingStyleSheet = document.createElement('style');
trendingStyleSheet.textContent = trendingCategoriesCSS;
document.head.appendChild(trendingStyleSheet);

// Trending & Categories Manager
class TrendingCategoriesManager {
    constructor() {
        this.categories = [
            "Campus News", "Academic Issues", "Student Life", 
            "Events & Activities", "Sports", "Clubs & Societies",
            "Housing", "Food & Dining", "Transportation",
            "Technology", "Career Services", "Health & Wellness",
            "International Students", "Graduate Studies", "Research"
        ];
        this.trendingListener = null;
        this.categoriesListener = null;
    }

    init() {
        console.log('TrendingCategoriesManager initializing...');
        this.loadTrendingTopics();
        this.loadCategories();
        this.setupRealTimeListeners();
    }

    setupRealTimeListeners() {
        // Listen for new posts to update trending topics
        this.trendingListener = db.collection('posts')
            .orderBy('createdAt', 'desc')
            .limit(50)
            .onSnapshot(() => {
                this.loadTrendingTopics();
            });

        // Listen for new comments to update engagement metrics
        this.categoriesListener = db.collection('comments')
            .orderBy('createdAt', 'desc')
            .limit(50)
            .onSnapshot(() => {
                this.loadTrendingTopics();
                this.loadCategories();
            });
    }

    async loadTrendingTopics() {
        const trendingList = document.getElementById('trendingList');
        if (!trendingList) return;

        try {
            // Show loading state
            trendingList.innerHTML = '<div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Loading trends...</div>';

            // Get recent posts with engagement data
            const postsSnapshot = await db.collection('posts')
                .orderBy('createdAt', 'desc')
                .limit(20)
                .get();

            const posts = postsSnapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));

            // Calculate trending score for each post
            const trendingPosts = await Promise.all(
                posts.map(async (post) => {
                    const engagementScore = await this.calculateEngagementScore(post.id);
                    return {
                        ...post,
                        engagementScore,
                        trendingScore: this.calculateTrendingScore(post, engagementScore)
                    };
                })
            );

            // Sort by trending score and take top 5
            const topTrending = trendingPosts
                .sort((a, b) => b.trendingScore - a.trendingScore)
                .slice(0, 5);

            this.renderTrendingTopics(topTrending, trendingList);

        } catch (error) {
            console.error('Error loading trending topics:', error);
            trendingList.innerHTML = '<div class="empty-state">Error loading trends</div>';
        }
    }

    async calculateEngagementScore(postId) {
        try {
            // Get comments count
            const commentsSnapshot = await db.collection('comments')
                .where('postId', '==', postId)
                .get();

            // Get reactions count
            const reactionsSnapshot = await db.collection('reactions')
                .where('targetType', '==', 'post')
                .where('targetId', '==', postId)
                .get();

            const commentsCount = commentsSnapshot.size;
            const reactionsCount = reactionsSnapshot.size;

            // Calculate engagement score (comments weigh more than reactions)
            return (commentsCount * 2) + reactionsCount;

        } catch (error) {
            console.error('Error calculating engagement score:', error);
            return 0;
        }
    }

    calculateTrendingScore(post, engagementScore) {
        // Consider post age (newer posts get higher score)
        const postAge = post.createdAt ? (Date.now() - post.createdAt.toDate().getTime()) : 0;
        const ageFactor = Math.max(0, 1 - (postAge / (24 * 60 * 60 * 1000))); // Decay over 24 hours

        // Consider initial engagement metrics
        const baseScore = engagementScore;

        // Apply age decay
        return baseScore * ageFactor;
    }

    renderTrendingTopics(trendingPosts, container) {
        if (trendingPosts.length === 0) {
            container.innerHTML = '<div class="empty-state">No trending topics yet</div>';
            return;
        }

        container.innerHTML = trendingPosts.map((post, index) => `
            <li class="trending-item" data-post-id="${post.id}">
                <div class="trending-rank top-${index + 1}">${index + 1}</div>
                <span class="trending-text">${this.truncateText(post.title, 30)}</span>
                <span class="trending-count">${Math.round(post.engagementScore)}</span>
            </li>
        `).join('');

        // Add click listeners to trending items
        container.querySelectorAll('.trending-item').forEach(item => {
            item.addEventListener('click', () => {
                const postId = item.dataset.postId;
                this.navigateToPost(postId);
            });
        });
    }

    async loadCategories() {
        const categoryList = document.getElementById('categoryList');
        if (!categoryList) return;

        try {
            // Show loading state
            categoryList.innerHTML = '<div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Loading categories...</div>';

            // For now, we'll use predefined categories with mock counts
            // In a real implementation, you'd categorize posts and count them
            const categoriesWithCounts = await this.getCategoriesWithCounts();

            this.renderCategories(categoriesWithCounts, categoryList);

        } catch (error) {
            console.error('Error loading categories:', error);
            categoryList.innerHTML = '<div class="empty-state">Error loading categories</div>';
        }
    }

    async getCategoriesWithCounts() {
        try {
            // Get all posts to categorize (in a real app, posts would have category field)
            const postsSnapshot = await db.collection('posts').get();
            const totalPosts = postsSnapshot.size;

            // For demo purposes, distribute posts randomly across categories
            // In production, you'd use actual post categories
            return this.categories.map((category, index) => {
                // Simulate post counts - in real app, this would be actual counts
                const baseCount = Math.floor(totalPosts / this.categories.length);
                const randomVariation = Math.floor(Math.random() * 5);
                const postCount = Math.max(1, baseCount + randomVariation - index);

                return {
                    name: category,
                    count: postCount,
                    slug: category.toLowerCase().replace(/ /g, '-')
                };
            }).sort((a, b) => b.count - a.count);

        } catch (error) {
            console.error('Error getting category counts:', error);
            return this.categories.map(category => ({
                name: category,
                count: 0,
                slug: category.toLowerCase().replace(/ /g, '-')
            }));
        }
    }

    renderCategories(categories, container) {
        if (categories.length === 0) {
            container.innerHTML = '<div class="empty-state">No categories available</div>';
            return;
        }

        container.innerHTML = categories.map(category => `
            <li class="category-item" data-category="${category.slug}">
                <span class="category-name">${category.name}</span>
                <span class="category-count">${category.count}</span>
            </li>
        `).join('');

        // Add click listeners to category items
        container.querySelectorAll('.category-item').forEach(item => {
            item.addEventListener('click', () => {
                const categorySlug = item.dataset.category;
                this.filterByCategory(categorySlug);
            });
        });
    }

    navigateToPost(postId) {
        // Scroll to the post and open comments
        const postElement = document.querySelector(`[data-post-id="${postId}"]`);
        if (postElement) {
            postElement.scrollIntoView({ behavior: 'smooth' });
            
            // If social features are available, open comments
            if (window.socialFeatures) {
                window.socialFeatures.toggleCommentsSection(postId);
            }
            
            // Add highlight effect
            postElement.style.backgroundColor = '#fff3cd';
            setTimeout(() => {
                postElement.style.backgroundColor = '';
            }, 2000);
        } else {
            showNotification('Post not found in current view', 'info');
        }
    }

    filterByCategory(categorySlug) {
        // This would filter posts by category in a real implementation
        // For now, show a notification and potentially filter the posts list
        const categoryName = this.categories.find(cat => 
            cat.toLowerCase().replace(/ /g, '-') === categorySlug
        ) || categorySlug;
        
        showNotification(`Filtering by category: ${categoryName}`, 'info');
        
        // In a full implementation, you would:
        // 1. Filter the posts list by category
        // 2. Update the URL or state
        // 3. Re-render the posts container
        
        console.log(`Filtering by category: ${categoryName} (${categorySlug})`);
    }

    truncateText(text, maxLength) {
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength) + '...';
    }

    // Advanced trending algorithm (optional - for more sophisticated trending)
    async calculateAdvancedTrending() {
        try {
            // Get posts from last 7 days
            const oneWeekAgo = new Date();
            oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

            const recentPosts = await db.collection('posts')
                .where('createdAt', '>=', oneWeekAgo)
                .orderBy('createdAt', 'desc')
                .get();

            const trendingData = await Promise.all(
                recentPosts.docs.map(async (doc) => {
                    const post = doc.data();
                    const postId = doc.id;

                    // Get engagement metrics
                    const [comments, reactions] = await Promise.all([
                        db.collection('comments').where('postId', '==', postId).get(),
                        db.collection('reactions').where('targetType', '==', 'post').where('targetId', '==', postId).get()
                    ]);

                    const commentsCount = comments.size;
                    const reactionsCount = reactions.size;

                    // Calculate velocity (engagement per hour)
                    const postAge = (Date.now() - post.createdAt.toDate().getTime()) / (1000 * 60 * 60);
                    const velocity = postAge > 0 ? (commentsCount + reactionsCount) / postAge : 0;

                    return {
                        id: postId,
                        title: post.title,
                        engagement: commentsCount + reactionsCount,
                        velocity: velocity,
                        score: this.calculateTrendingAlgorithm(commentsCount, reactionsCount, velocity, postAge)
                    };
                })
            );

            return trendingData.sort((a, b) => b.score - a.score).slice(0, 10);

        } catch (error) {
            console.error('Error in advanced trending calculation:', error);
            return [];
        }
    }

    calculateTrendingAlgorithm(comments, reactions, velocity, ageInHours) {
        // Weight different factors
        const commentWeight = 2.0;
        const reactionWeight = 1.0;
        const velocityWeight = 1.5;
        const ageDecay = Math.exp(-ageInHours / 24); // Exponential decay over 24 hours

        return ((comments * commentWeight) + (reactions * reactionWeight) + (velocity * velocityWeight)) * ageDecay;
    }

    // Method to update categories based on actual post data (for future implementation)
    async updateCategoriesFromPosts() {
        // This would analyze post content and automatically categorize posts
        // For now, it's a placeholder for future machine learning implementation
        console.log('Categories would be updated based on post content analysis');
    }

    cleanup() {
        if (this.trendingListener) {
            this.trendingListener();
        }
        if (this.categoriesListener) {
            this.categoriesListener();
        }
    }
}

// Initialize trending and categories when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    console.log('Initializing trending and categories...');
    
    const trendingManager = new TrendingCategoriesManager();
    trendingManager.init();
    
    // Make it globally available
    window.trendingManager = trendingManager;
});

// Utility functions for manual testing
window.trendingUtils = {
    refreshTrending: () => {
        if (window.trendingManager) {
            window.trendingManager.loadTrendingTopics();
            window.trendingManager.loadCategories();
            showNotification('Trending topics refreshed', 'success');
        }
    },
    
    simulateHighEngagement: async () => {
        // Create a post with simulated high engagement for testing
        if (!auth.currentUser) {
            showNotification('Please sign in first', 'error');
            return;
        }
        
        try {
            const postRef = await db.collection('posts').add({
                title: ' Trending Test Post - High Engagement',
                content: 'This is a test post to demonstrate trending functionality with simulated high engagement metrics.',
                authorId: auth.currentUser.uid,
                authorName: auth.currentUser.displayName || 'Test User',
                likesCount: 15,
                dislikesCount: 2,
                commentsCount: 8,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            // Add some simulated reactions
            for (let i = 0; i < 15; i++) {
                await db.collection('reactions').add({
                    targetType: 'post',
                    targetId: postRef.id,
                    userId: `test-user-${i}`,
                    userName: `Test User ${i}`,
                    type: Math.random() > 0.2 ? 'like' : 'dislike',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
            
            // Add some simulated comments
            for (let i = 0; i < 8; i++) {
                await db.collection('comments').add({
                    postId: postRef.id,
                    content: `Test comment ${i + 1} on trending post`,
                    authorId: `test-user-${i}`,
                    authorName: `Test User ${i}`,
                    parentCommentId: null,
                    likesCount: Math.floor(Math.random() * 5),
                    dislikesCount: Math.floor(Math.random() * 2),
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
            
            showNotification('High engagement test post created!', 'success');
            
        } catch (error) {
            console.error('Error creating test post:', error);
            showNotification('Error creating test post: ' + error.message, 'error');
        }
    },
    
    showTrendingStats: async () => {
        if (window.trendingManager) {
            const advancedTrending = await window.trendingManager.calculateAdvancedTrending();
            console.log('Advanced Trending Stats:', advancedTrending);
            
            let message = 'Top Trending Posts:\\n';
            advancedTrending.slice(0, 3).forEach((post, index) => {
                message += `\\n${index + 1}. ${post.title}\\n   Score: ${post.score.toFixed(2)}, Engagement: ${post.engagement}\\n`;
            });
            
            alert(message);
        }
    }
};

// Update your existing sidebar HTML structure to include these elements:
// Make sure you have these elements in your HTML:
/*
<div class="sidebar-card">
    <h3 class="sidebar-title">Trending Topics</h3>
    <ul class="trending-list" id="trendingList">
        <!-- Trending topics will be dynamically loaded here -->
    </ul>
</div>

<div class="sidebar-card">
    <h3 class="sidebar-title">Categories</h3>
    <ul class="category-list" id="categoryList">
        <!-- Categories will be dynamically loaded here -->
    </ul>
</div>
*/

console.log('Trending Topics & Categories module loaded successfully!');
        
        
        
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       // ===============================
// All Discussions Page Implementation
// ===============================

// Add CSS for discussions page
const discussionsCSS = `
/* Discussions Page Styles */
.discussions-header {
    display: flex;
    justify-content: between;
    align-items: center;
    margin-bottom: 30px;
    flex-wrap: wrap;
    gap: 15px;
}

.discussions-filters {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
}

.filter-btn {
    padding: 8px 16px;
    border: 1px solid #ddd;
    background: white;
    border-radius: 20px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: all 0.3s ease;
}

.filter-btn.active {
    background: var(--secondary);
    color: white;
    border-color: var(--secondary);
}

.filter-btn:hover {
    background: #f8f9fa;
}

.filter-btn.active:hover {
    background: var(--secondary);
}

.search-box {
    position: relative;
    flex: 1;
    min-width: 250px;
}

.search-input {
    width: 100%;
    padding: 10px 40px 10px 15px;
    border: 1px solid #ddd;
    border-radius: 20px;
    font-size: 0.9rem;
}

.search-icon {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--gray);
}

.discussions-stats {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    padding: 15px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}

.stat-card {
    text-align: center;
    flex: 1;
}

.stat-number {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--secondary);
}

.stat-label {
    font-size: 0.8rem;
    color: var(--gray);
}

.discussions-grid {
    display: grid;
    gap: 20px;
}

.discussion-card {
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    transition: all 0.3s ease;
    cursor: pointer;
}

.discussion-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

.discussion-header {
    display: flex;
    justify-content: between;
    align-items: start;
    margin-bottom: 15px;
}

.discussion-title {
    font-size: 1.3rem;
    font-weight: 600;
    margin-bottom: 10px;
    color: var(--dark);
    line-height: 1.4;
}

.discussion-meta {
    display: flex;
    gap: 15px;
    align-items: center;
    margin-bottom: 10px;
    flex-wrap: wrap;
}

.discussion-author {
    display: flex;
    align-items: center;
    gap: 8px;
}

.author-avatar {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: var(--secondary);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
    font-weight: bold;
}

.author-name {
    font-weight: 500;
    font-size: 0.9rem;
}

.discussion-time {
    font-size: 0.8rem;
    color: var(--gray);
}

.discussion-category {
    background: #e3f2fd;
    color: var(--secondary);
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.7rem;
    font-weight: 500;
}

.discussion-content {
    margin-bottom: 15px;
    line-height: 1.6;
    color: var(--dark);
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

.discussion-image-preview {
    margin: 15px 0;
}

.discussion-image-preview img {
    max-width: 200px;
    max-height: 150px;
    border-radius: 8px;
    object-fit: cover;
}

.discussion-stats {
    display: flex;
    gap: 20px;
    padding-top: 15px;
    border-top: 1px solid #f0f0f0;
}

.discussion-stat {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 0.9rem;
    color: var(--gray);
}

.discussion-stat i {
    font-size: 0.8rem;
}

.stat-likes { color: #1877f2; }
.stat-dislikes { color: #ff4444; }
.stat-comments { color: var(--secondary); }

.discussion-actions {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}

.action-btn-small {
    padding: 6px 12px;
    border: 1px solid #ddd;
    background: white;
    border-radius: 15px;
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.action-btn-small:hover {
    background: #f8f9fa;
    border-color: var(--secondary);
}

.pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    margin-top: 30px;
    padding: 20px;
}

.pagination-btn {
    padding: 8px 16px;
    border: 1px solid #ddd;
    background: white;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.pagination-btn:hover:not(:disabled) {
    background: var(--secondary);
    color: white;
    border-color: var(--secondary);
}

.pagination-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.pagination-info {
    font-size: 0.9rem;
    color: var(--gray);
}

.loading-discussions {
    text-align: center;
    padding: 40px;
    color: var(--gray);
}

.empty-discussions {
    text-align: center;
    padding: 60px 20px;
    color: var(--gray);
}

.empty-discussions i {
    font-size: 3rem;
    margin-bottom: 20px;
    opacity: 0.5;
}

.empty-discussions h3 {
    margin-bottom: 10px;
    color: var(--dark);
}

.discussion-tags {
    display: flex;
    gap: 5px;
    margin: 10px 0;
    flex-wrap: wrap;
}

.discussion-tag {
    background: #f8f9fa;
    color: var(--dark-gray);
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 0.7rem;
}

.discussion-featured {
    border-left: 4px solid var(--accent);
}

.discussion-popular {
    border-left: 4px solid #ffd700;
}

.discussion-hot {
    border-left: 4px solid #ff6b6b;
}

@media (max-width: 768px) {
    .discussions-header {
        flex-direction: column;
        align-items: stretch;
    }
    
    .discussions-filters {
        justify-content: center;
    }
    
    .search-box {
        min-width: 100%;
    }
    
    .discussion-header {
        flex-direction: column;
        gap: 10px;
    }
    
    .discussion-meta {
        justify-content: space-between;
    }
}
`;

// Add CSS to document
const discussionsStyleSheet = document.createElement('style');
discussionsStyleSheet.textContent = discussionsCSS;
document.head.appendChild(discussionsStyleSheet);

// Discussions Page Manager
class DiscussionsManager {
    constructor() {
        this.currentFilter = 'all';
        this.currentSearch = '';
        this.currentPage = 1;
        this.postsPerPage = 10;
        this.totalPosts = 0;
        this.discussionsListener = null;
        this.allPosts = [];
    }

    init() {
        console.log('DiscussionsManager initializing...');
        this.setupEventListeners();
        this.loadDiscussions();
    }

    setupEventListeners() {
        // Filter buttons
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('filter-btn')) {
                this.handleFilterChange(e.target.dataset.filter);
            }
            
            if (e.target.classList.contains('discussion-card')) {
                this.handleDiscussionClick(e.target.dataset.postId);
            }
            
            if (e.target.closest('.discussion-card')) {
                const card = e.target.closest('.discussion-card');
                this.handleDiscussionClick(card.dataset.postId);
            }
        });

        // Search functionality
        const searchInput = document.getElementById('discussionsSearch');
        if (searchInput) {
            let searchTimeout;
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    this.handleSearch(e.target.value);
                }, 500);
            });
        }

        // Pagination
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('pagination-btn')) {
                const action = e.target.dataset.action;
                this.handlePagination(action);
            }
        });
    }

    async loadDiscussions() {
        const discussionsContainer = document.getElementById('discussionsContainer');
        if (!discussionsContainer) return;

        try {
            // Show loading state
            discussionsContainer.innerHTML = `
                <div class="loading-discussions">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Loading discussions...</p>
                </div>
            `;

            // Build query based on current filter and search
            let query = db.collection('posts');

            // Apply filters
            switch (this.currentFilter) {
                case 'recent':
                    query = query.orderBy('createdAt', 'desc');
                    break;
                case 'popular':
                    query = query.orderBy('likesCount', 'desc');
                    break;
                case 'commented':
                    query = query.orderBy('commentsCount', 'desc');
                    break;
                default:
                    query = query.orderBy('createdAt', 'desc');
            }

            // Get total count for pagination
            const countSnapshot = await query.get();
            this.totalPosts = countSnapshot.size;

            // Apply pagination
            const startAt = (this.currentPage - 1) * this.postsPerPage;
            query = query.limit(this.postsPerPage);
            
            if (startAt > 0) {
                const startDoc = countSnapshot.docs[startAt - 1];
                query = query.startAfter(startDoc);
            }

            const snapshot = await query.get();
            this.allPosts = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));

            // Apply search filter if any
            let filteredPosts = this.allPosts;
            if (this.currentSearch) {
                filteredPosts = this.filterPostsBySearch(this.allPosts, this.currentSearch);
            }

            this.renderDiscussions(filteredPosts);
            this.updatePagination();
            this.updateStats();

        } catch (error) {
            console.error('Error loading discussions:', error);
            discussionsContainer.innerHTML = `
                <div class="empty-discussions">
                    <i class="fas fa-exclamation-triangle"></i>
                    <h3>Error Loading Discussions</h3>
                    <p>Please try refreshing the page</p>
                </div>
            `;
        }
    }

    filterPostsBySearch(posts, searchTerm) {
        const term = searchTerm.toLowerCase();
        return posts.filter(post => 
            post.title.toLowerCase().includes(term) ||
            post.content.toLowerCase().includes(term) ||
            post.authorName.toLowerCase().includes(term)
        );
    }

    renderDiscussions(posts) {
        const discussionsContainer = document.getElementById('discussionsContainer');
        if (!discussionsContainer) return;

        if (posts.length === 0) {
            discussionsContainer.innerHTML = `
                <div class="empty-discussions">
                    <i class="fas fa-comments"></i>
                    <h3>No Discussions Found</h3>
                    <p>${this.currentSearch ? 'Try adjusting your search terms' : 'Be the first to start a discussion!'}</p>
                    ${!this.currentSearch ? `
                        <button class="btn btn-primary mt-20" onclick="socialFeatures.showCreatePostModal()">
                            Start a Discussion
                        </button>
                    ` : ''}
                </div>
            `;
            return;
        }

        discussionsContainer.innerHTML = `
            <div class="discussions-stats">
                <div class="stat-card">
                    <div class="stat-number">${posts.length}</div>
                    <div class="stat-label">Discussions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${this.getTotalComments(posts)}</div>
                    <div class="stat-label">Total Comments</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${this.getTotalLikes(posts)}</div>
                    <div class="stat-label">Total Likes</div>
                </div>
            </div>
            <div class="discussions-grid">
                ${posts.map(post => this.createDiscussionCard(post)).join('')}
            </div>
        `;
    }

    createDiscussionCard(post) {
        const isPopular = post.likesCount > 10;
        const isHot = post.commentsCount > 5;
        const isFeatured = post.likesCount > 20;
        
        let specialClass = '';
        if (isFeatured) specialClass = 'discussion-featured';
        else if (isHot) specialClass = 'discussion-hot';
        else if (isPopular) specialClass = 'discussion-popular';

        // Extract first few tags from content (simplified)
        const tags = this.extractTags(post.content).slice(0, 3);

        return `
            <div class="discussion-card ${specialClass}" data-post-id="${post.id}">
                <div class="discussion-header">
                    <div style="flex: 1;">
                        <h3 class="discussion-title">${post.title}</h3>
                        <div class="discussion-meta">
                            <div class="discussion-author">
                                <div class="author-avatar">${post.authorName.charAt(0).toUpperCase()}</div>
                                <span class="author-name">${post.authorName}</span>
                            </div>
                            <div class="discussion-time">${this.formatTime(post.createdAt)}</div>
                            <div class="discussion-category">${this.getPostCategory(post)}</div>
                        </div>
                    </div>
                </div>
                
                ${tags.length > 0 ? `
                    <div class="discussion-tags">
                        ${tags.map(tag => `<span class="discussion-tag">#${tag}</span>`).join('')}
                    </div>
                ` : ''}
                
                <div class="discussion-content">
                    ${this.truncateContent(post.content, 150)}
                </div>
                
                ${post.imageUrl ? `
                    <div class="discussion-image-preview">
                        <img src="${post.imageUrl}" alt="Discussion image" onclick="event.stopPropagation()">
                    </div>
                ` : ''}
                
                <div class="discussion-stats">
                    <div class="discussion-stat stat-likes">
                        <i class="fas fa-thumbs-up"></i>
                        <span>${post.likesCount || 0}</span>
                    </div>
                    <div class="discussion-stat stat-dislikes">
                        <i class="fas fa-thumbs-down"></i>
                        <span>${post.dislikesCount || 0}</span>
                    </div>
                    <div class="discussion-stat stat-comments">
                        <i class="fas fa-comments"></i>
                        <span>${post.commentsCount || 0}</span>
                    </div>
                </div>
                
                <div class="discussion-actions">
                    <button class="action-btn-small" onclick="event.stopPropagation(); socialFeatures.handleReaction(this.closest('.like-btn'))">
                        <i class="fas fa-thumbs-up"></i> Like
                    </button>
                    <button class="action-btn-small" onclick="event.stopPropagation(); socialFeatures.handleDiscussionComment('${post.id}')">
                        <i class="fas fa-comment"></i> Comment
                    </button>
                    <button class="action-btn-small" onclick="event.stopPropagation(); this.shareDiscussion('${post.id}')">
                        <i class="fas fa-share"></i> Share
                    </button>
                </div>
            </div>
        `;
    }

    extractTags(content) {
        // Simple tag extraction - in real app, use proper NLP or predefined tags
        const words = content.toLowerCase().split(/\s+/);
        const commonWords = new Set(['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by']);
        const tags = words.filter(word => 
            word.length > 3 && 
            !commonWords.has(word) && 
            word.match(/^[a-z]+$/)
        );
        return [...new Set(tags)].slice(0, 5);
    }

    getPostCategory(post) {
        // Simple category detection based on content
        const content = post.content.toLowerCase();
        if (content.includes('campus') || content.includes('university')) return 'Campus';
        if (content.includes('exam') || content.includes('study')) return 'Academic';
        if (content.includes('event') || content.includes('meeting')) return 'Events';
        if (content.includes('sport') || content.includes('game')) return 'Sports';
        return 'General';
    }

    handleFilterChange(filter) {
        this.currentFilter = filter;
        this.currentPage = 1;
        
        // Update active filter button
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.filter === filter);
        });
        
        this.loadDiscussions();
    }

    handleSearch(searchTerm) {
        this.currentSearch = searchTerm;
        this.currentPage = 1;
        this.loadDiscussions();
    }

    handlePagination(action) {
        const totalPages = Math.ceil(this.totalPosts / this.postsPerPage);
        
        switch (action) {
            case 'prev':
                if (this.currentPage > 1) this.currentPage--;
                break;
            case 'next':
                if (this.currentPage < totalPages) this.currentPage++;
                break;
            case 'first':
                this.currentPage = 1;
                break;
            case 'last':
                this.currentPage = totalPages;
                break;
        }
        
        this.loadDiscussions();
    }

    updatePagination() {
        const paginationContainer = document.getElementById('discussionsPagination');
        if (!paginationContainer) return;

        const totalPages = Math.ceil(this.totalPosts / this.postsPerPage);
        
        if (totalPages <= 1) {
            paginationContainer.innerHTML = '';
            return;
        }

        paginationContainer.innerHTML = `
            <button class="pagination-btn" data-action="first" ${this.currentPage === 1 ? 'disabled' : ''}>
                <i class="fas fa-angle-double-left"></i>
            </button>
            <button class="pagination-btn" data-action="prev" ${this.currentPage === 1 ? 'disabled' : ''}>
                <i class="fas fa-angle-left"></i>
            </button>
            
            <span class="pagination-info">
                Page ${this.currentPage} of ${totalPages}
            </span>
            
            <button class="pagination-btn" data-action="next" ${this.currentPage === totalPages ? 'disabled' : ''}>
                <i class="fas fa-angle-right"></i>
            </button>
            <button class="pagination-btn" data-action="last" ${this.currentPage === totalPages ? 'disabled' : ''}>
                <i class="fas fa-angle-double-right"></i>
            </button>
        `;
    }

    updateStats() {
        // Additional stats could be updated here
        console.log('Discussions stats updated');
    }

    handleDiscussionClick(postId) {
        // Navigate to the post and open it
        if (window.socialFeatures) {
            // If we're already on discussions page, we might want to show the post in a modal
            // or scroll to it if it's in the current view
            this.showPostModal(postId);
        }
    }

    async showPostModal(postId) {
        try {
            const postDoc = await db.collection('posts').doc(postId).get();
            if (!postDoc.exists) {
                showNotification('Post not found', 'error');
                return;
            }

            const post = postDoc.data();
            
            // Create modal to view post
            const modalHTML = `
                <div class="modal-overlay" id="postModal">
                    <div class="modal-content" style="max-width: 800px;">
                        <div class="modal-header">
                            <h3>${post.title}</h3>
                            <button class="close-modal">&times;</button>
                        </div>
                        <div class="post-content">
                            <div class="discussion-meta">
                                <div class="discussion-author">
                                    <div class="author-avatar">${post.authorName.charAt(0).toUpperCase()}</div>
                                    <span class="author-name">${post.authorName}</span>
                                </div>
                                <div class="discussion-time">${this.formatTime(post.createdAt)}</div>
                            </div>
                            <div class="post-body">
                                ${post.content}
                            </div>
                            ${post.imageUrl ? `
                                <div class="post-image">
                                    <img src="${post.imageUrl}" alt="Post image" style="max-width: 100%; border-radius: 8px;">
                                </div>
                            ` : ''}
                        </div>
                        <div class="modal-actions">
                            <button class="btn btn-secondary" onclick="this.closePostModal()">Close</button>
                            <button class="btn btn-primary" onclick="socialFeatures.toggleCommentsSection('${postId}'); this.closePostModal()">
                                View Comments
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            const modal = document.getElementById('postModal');
            modal.querySelector('.close-modal').addEventListener('click', () => this.closePostModal());
            modal.addEventListener('click', (e) => {
                if (e.target === modal) this.closePostModal();
            });

        } catch (error) {
            console.error('Error showing post modal:', error);
            showNotification('Error loading post', 'error');
        }
    }

    closePostModal() {
        const modal = document.getElementById('postModal');
        if (modal) modal.remove();
    }

    getTotalComments(posts) {
        return posts.reduce((total, post) => total + (post.commentsCount || 0), 0);
    }

    getTotalLikes(posts) {
        return posts.reduce((total, post) => total + (post.likesCount || 0), 0);
    }

    truncateContent(content, maxLength) {
        if (content.length <= maxLength) return content;
        return content.substring(0, maxLength) + '...';
    }

    formatTime(timestamp) {
        if (!timestamp) return '';
        const date = timestamp.toDate();
        const now = new Date();
        const diff = now - date;
        
        const minute = 60 * 1000;
        const hour = minute * 60;
        const day = hour * 24;
        
        if (diff < minute) return 'Just now';
        if (diff < hour) return `${Math.floor(diff / minute)}m ago`;
        if (diff < day) return `${Math.floor(diff / hour)}h ago`;
        if (diff < day * 7) return `${Math.floor(diff / day)}d ago`;
        
        return date.toLocaleDateString();
    }

    // Method to handle comments from discussions page
    handleDiscussionComment(postId) {
        if (window.socialFeatures) {
            window.socialFeatures.showCreatePostModal();
            // You might want to pre-fill the post reference or open comments directly
        }
    }

    shareDiscussion(postId) {
        const url = `${window.location.origin}${window.location.pathname}?post=${postId}`;
        navigator.clipboard.writeText(url).then(() => {
            showNotification('Discussion link copied to clipboard!', 'success');
        }).catch(() => {
            // Fallback for older browsers
            prompt('Copy this link to share:', url);
        });
    }

    cleanup() {
        if (this.discussionsListener) {
            this.discussionsListener();
        }
    }
}

// Initialize discussions page when DOM is loaded and page is active
function initDiscussionsPage() {
    const discussionsPage = document.getElementById('discussions');
    if (discussionsPage && discussionsPage.classList.contains('active')) {
        console.log('Initializing discussions page...');
        
        const discussionsManager = new DiscussionsManager();
        discussionsManager.init();
        
        // Make it globally available
        window.discussionsManager = discussionsManager;
    }
}

// Listen for page navigation to discussions
document.addEventListener('DOMContentLoaded', () => {
    // Check if we're already on discussions page
    initDiscussionsPage();
    
    // Also listen for page changes
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                if (mutation.target.id === 'discussions' && mutation.target.classList.contains('active')) {
                    initDiscussionsPage();
                }
            }
        });
    });
    
    const discussionsPage = document.getElementById('discussions');
    if (discussionsPage) {
        observer.observe(discussionsPage, { attributes: true });
    }
});

// Update your discussions page HTML to include this structure:
/*
<div id="discussions" class="page">
    <div class="discussions-header">
        <h2>All Discussions</h2>
        <div class="discussions-filters">
            <button class="filter-btn active" data-filter="all">All</button>
            <button class="filter-btn" data-filter="recent">Recent</button>
            <button class="filter-btn" data-filter="popular">Popular</button>
            <button class="filter-btn" data-filter="commented">Most Commented</button>
            <div class="search-box">
                <input type="text" class="search-input" id="discussionsSearch" placeholder="Search discussions...">
                <i class="fas fa-search search-icon"></i>
            </div>
        </div>
    </div>
    
    <div id="discussionsContainer">
        <!-- Discussions will be loaded here -->
    </div>
    
    <div id="discussionsPagination" class="pagination">
        <!-- Pagination will be loaded here -->
    </div>
</div>
*/

// Utility functions for testing
window.discussionsUtils = {
    createSampleDiscussions: async (count = 5) => {
        if (!auth.currentUser) {
            showNotification('Please sign in first', 'error');
            return;
        }

        const sampleTitles = [
            "What's your favorite spot on campus?",
            "Study tips for final exams",
            "Upcoming campus events discussion",
            "Best places to eat near university",
            "Student club recommendations",
            "Campus transportation issues",
            "Library resources discussion",
            "Sports teams performance this season",
            "International students support",
            "Career fair preparation tips"
        ];

        const sampleContent = [
            "I wanted to start a discussion about this topic that many students are interested in. What are your thoughts and experiences?",
            "This has been on my mind lately and I think it's important for us to discuss as a student community.",
            "I've noticed this issue affecting many students and wanted to bring it up for discussion. Let me know your perspectives.",
            "Looking for advice and opinions from fellow students who might have experience with this situation.",
            "This topic doesn't get enough discussion but I believe it's crucial for our student experience."
        ];

        try {
            for (let i = 0; i < count; i++) {
                const randomTitle = sampleTitles[Math.floor(Math.random() * sampleTitles.length)];
                const randomContent = sampleContent[Math.floor(Math.random() * sampleContent.length)];
                
                await db.collection('posts').add({
                    title: randomTitle,
                    content: randomContent,
                    authorId: auth.currentUser.uid,
                    authorName: auth.currentUser.displayName || 'Test User',
                    likesCount: Math.floor(Math.random() * 20),
                    dislikesCount: Math.floor(Math.random() * 5),
                    commentsCount: Math.floor(Math.random() * 15),
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
            
            showNotification(`${count} sample discussions created!`, 'success');
            
            // Refresh discussions if manager exists
            if (window.discussionsManager) {
                window.discussionsManager.loadDiscussions();
            }
            
        } catch (error) {
            console.error('Error creating sample discussions:', error);
            showNotification('Error creating discussions: ' + error.message, 'error');
        }
    },

    clearAllDiscussions: async () => {
        if (!confirm('This will delete ALL discussions. Are you sure?')) return;
        
        try {
            const postsSnapshot = await db.collection('posts').get();
            const batch = db.batch();
            postsSnapshot.docs.forEach(doc => batch.delete(doc.ref));
            await batch.commit();
            
            showNotification('All discussions cleared!', 'success');
            
            if (window.discussionsManager) {
                window.discussionsManager.loadDiscussions();
            }
            
        } catch (error) {
            console.error('Error clearing discussions:', error);
            showNotification('Error clearing discussions: ' + error.message, 'error');
        }
    }
};

console.log('Discussions page module loaded successfully!');
       
       
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        // ===============================
// Messaging System Implementation
// ===============================

// Add CSS for messaging system
const messagingCSS = `
/* Messaging System Styles */
.messaging-container {
    display: grid;
    grid-template-columns: 350px 1fr;
    gap: 20px;
    height: 70vh;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    overflow: hidden;
}

.conversations-sidebar {
    border-right: 1px solid #eee;
    display: flex;
    flex-direction: column;
}

.conversations-header {
    padding: 20px;
    border-bottom: 1px solid #eee;
}

.conversations-search {
    position: relative;
    margin-bottom: 15px;
}

.conversations-search input {
    width: 100%;
    padding: 10px 35px 10px 15px;
    border: 1px solid #ddd;
    border-radius: 20px;
    font-size: 0.9rem;
}

.conversations-search i {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--gray);
}

.new-conversation-btn {
    width: 100%;
    padding: 10px;
    background: var(--secondary);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
}

.conversations-list {
    flex: 1;
    overflow-y: auto;
}

.conversation-item {
    padding: 15px 20px;
    border-bottom: 1px solid #f5f5f5;
    cursor: pointer;
    transition: background-color 0.3s ease;
    display: flex;
    align-items: center;
    gap: 12px;
}

.conversation-item:hover {
    background: #f8f9fa;
}

.conversation-item.active {
    background: #e3f2fd;
    border-right: 3px solid var(--secondary);
}

.conversation-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--secondary);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 0.9rem;
}

.conversation-info {
    flex: 1;
    min-width: 0;
}

.conversation-name {
    font-weight: 600;
    margin-bottom: 4px;
    font-size: 0.9rem;
}

.conversation-preview {
    font-size: 0.8rem;
    color: var(--gray);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.conversation-meta {
    text-align: right;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 4px;
}

.conversation-time {
    font-size: 0.7rem;
    color: var(--gray);
}

.conversation-unread {
    background: var(--accent);
    color: white;
    border-radius: 50%;
    width: 18px;
    height: 18px;
    font-size: 0.7rem;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Chat Area */
.chat-area {
    display: flex;
    flex-direction: column;
}

.chat-header {
    padding: 20px;
    border-bottom: 1px solid #eee;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.chat-user-info {
    display: flex;
    align-items: center;
    gap: 12px;
}

.chat-user-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--secondary);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
}

.chat-user-details h3 {
    margin-bottom: 4px;
    font-size: 1rem;
}

.chat-user-status {
    font-size: 0.8rem;
    color: var(--success);
}

.chat-actions {
    display: flex;
    gap: 10px;
}

.chat-action-btn {
    background: none;
    border: none;
    color: var(--gray);
    cursor: pointer;
    font-size: 1rem;
    padding: 5px;
}

.chat-action-btn:hover {
    color: var(--secondary);
}

.messages-container {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 15px;
    background: #f8f9fa;
}

.message {
    max-width: 70%;
    padding: 12px 16px;
    border-radius: 18px;
    position: relative;
    word-wrap: break-word;
}

.message.sent {
    align-self: flex-end;
    background: var(--secondary);
    color: white;
    border-bottom-right-radius: 4px;
}

.message.received {
    align-self: flex-start;
    background: white;
    border: 1px solid #e0e0e0;
    border-bottom-left-radius: 4px;
}

.message-sender {
    font-weight: 600;
    font-size: 0.8rem;
    margin-bottom: 4px;
    color: var(--secondary);
}

.message-content {
    line-height: 1.4;
}

.message-time {
    font-size: 0.7rem;
    opacity: 0.7;
    text-align: right;
    margin-top: 5px;
}

.message.received .message-time {
    text-align: left;
    color: var(--gray);
}

.message-status {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 0.7rem;
    margin-top: 4px;
}

.chat-input-area {
    padding: 20px;
    border-top: 1px solid #eee;
    background: white;
}

.chat-input-container {
    display: flex;
    gap: 10px;
    align-items: flex-end;
}

.chat-input {
    flex: 1;
    padding: 12px 15px;
    border: 1px solid #ddd;
    border-radius: 24px;
    resize: none;
    font-family: inherit;
    font-size: 0.9rem;
    max-height: 120px;
    min-height: 44px;
}

.chat-input:focus {
    outline: none;
    border-color: var(--secondary);
}

.send-btn {
    background: var(--secondary);
    color: white;
    border: none;
    border-radius: 50%;
    width: 44px;
    height: 44px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.3s ease;
}

.send-btn:hover {
    background: var(--primary);
}

.send-btn:disabled {
    background: var(--gray);
    cursor: not-allowed;
}

.attachment-btn {
    background: none;
    border: none;
    color: var(--gray);
    cursor: pointer;
    font-size: 1.2rem;
    padding: 10px;
}

.attachment-btn:hover {
    color: var(--secondary);
}

.typing-indicator {
    padding: 10px 20px;
    font-size: 0.8rem;
    color: var(--gray);
    font-style: italic;
}

.empty-chat {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: var(--gray);
    text-align: center;
}

.empty-chat i {
    font-size: 4rem;
    margin-bottom: 20px;
    opacity: 0.5;
}

.empty-conversations {
    padding: 40px 20px;
    text-align: center;
    color: var(--gray);
}

.empty-conversations i {
    font-size: 3rem;
    margin-bottom: 15px;
    opacity: 0.5;
}

.no-conversation-selected {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--gray);
    text-align: center;
}

.no-conversation-selected i {
    font-size: 4rem;
    margin-bottom: 20px;
    opacity: 0.5;
}

/* New Conversation Modal */
.new-conversation-modal .modal-content {
    max-width: 500px;
}

.users-list {
    max-height: 400px;
    overflow-y: auto;
}

.user-item {
    padding: 15px;
    border-bottom: 1px solid #f5f5f5;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 12px;
    transition: background-color 0.3s ease;
}

.user-item:hover {
    background: #f8f9fa;
}

.user-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--secondary);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
}

.user-info {
    flex: 1;
}

.user-name {
    font-weight: 600;
    margin-bottom: 4px;
}

.user-department {
    font-size: 0.8rem;
    color: var(--gray);
}

.message-attachment {
    margin-top: 8px;
    padding: 8px;
    background: rgba(255,255,255,0.1);
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.8rem;
}

.message-attachment img {
    max-width: 100px;
    max-height: 100px;
    border-radius: 4px;
}

.attachment-preview {
    margin-top: 10px;
    padding: 10px;
    background: #f8f9fa;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.attachment-preview img {
    max-width: 100px;
    max-height: 100px;
    border-radius: 4px;
}

.remove-attachment {
    background: none;
    border: none;
    color: var(--danger);
    cursor: pointer;
    padding: 5px;
}

@media (max-width: 768px) {
    .messaging-container {
        grid-template-columns: 1fr;
        height: 80vh;
    }
    
    .conversations-sidebar {
        display: none;
    }
    
    .conversations-sidebar.mobile-visible {
        display: flex;
    }
    
    .chat-area.mobile-hidden {
        display: none;
    }
    
    .mobile-toggle {
        display: block;
    }
    
    .message {
        max-width: 85%;
    }
}

.mobile-toggle {
    display: none;
    background: none;
    border: none;
    color: var(--secondary);
    cursor: pointer;
    font-size: 1.2rem;
    padding: 5px;
}

.online-indicator {
    width: 8px;
    height: 8px;
    background: var(--success);
    border-radius: 50%;
    position: absolute;
    bottom: 2px;
    right: 2px;
    border: 2px solid white;
}

.conversation-avatar, .chat-user-avatar {
    position: relative;
}

.message-reactions {
    display: flex;
    gap: 5px;
    margin-top: 5px;
    flex-wrap: wrap;
}

.reaction {
    background: rgba(255,255,255,0.2);
    padding: 2px 6px;
    border-radius: 12px;
    font-size: 0.7rem;
    display: flex;
    align-items: center;
    gap: 2px;
}

.message.received .reaction {
    background: #f0f0f0;
}
`;

// Add CSS to document
const messagingStyleSheet = document.createElement('style');
messagingStyleSheet.textContent = messagingCSS;
document.head.appendChild(messagingStyleSheet);

// Messaging System Manager
class MessagingManager {
    constructor() {
        this.currentUser = null;
        this.currentConversation = null;
        this.conversationsListener = null;
        this.messagesListener = null;
        this.typingListener = null;
        this.conversations = new Map();
        this.usersCache = new Map();
        this.typingTimeout = null;
    }

    init() {
        console.log('MessagingManager initializing...');
        
        auth.onAuthStateChanged(user => {
            this.currentUser = user;
            if (user) {
                this.setupRealTimeListeners();
                this.renderMessagingUI();
            } else {
                this.cleanup();
                this.showLoginPrompt();
            }
        });
    }

    renderMessagingUI() {
        const messagesContainer = document.getElementById('messages');
        if (!messagesContainer) return;

        messagesContainer.innerHTML = `
            <div class="messaging-container">
                <div class="conversations-sidebar" id="conversationsSidebar">
                    <div class="conversations-header">
                        <h3>Messages</h3>
                        <div class="conversations-search">
                            <input type="text" id="conversationsSearch" placeholder="Search conversations...">
                            <i class="fas fa-search"></i>
                        </div>
                        <button class="new-conversation-btn" id="newConversationBtn">
                            <i class="fas fa-plus"></i> New Conversation
                        </button>
                    </div>
                    <div class="conversations-list" id="conversationsList">
                        <div class="loading-conversations">
                            <i class="fas fa-spinner fa-spin"></i> Loading conversations...
                        </div>
                    </div>
                </div>
                
                <div class="chat-area" id="chatArea">
                    <div class="no-conversation-selected">
                        <i class="fas fa-comment-alt"></i>
                        <h3>Select a conversation</h3>
                        <p>Choose a conversation from the sidebar or start a new one</p>
                    </div>
                </div>
            </div>
        `;

        this.setupEventListeners();
    }

    setupEventListeners() {
        // New conversation button
        const newConversationBtn = document.getElementById('newConversationBtn');
        if (newConversationBtn) {
            newConversationBtn.addEventListener('click', () => {
                this.showNewConversationModal();
            });
        }

        // Search functionality
        const searchInput = document.getElementById('conversationsSearch');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                this.filterConversations(e.target.value);
            });
        }

        // Send message on Enter key (with Shift for new line)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.classList.contains('chat-input') && !e.shiftKey) {
                e.preventDefault();
                this.sendMessage();
            }
        });
    }

    setupRealTimeListeners() {
        if (!this.currentUser) return;

        // Listen for conversations where current user is a participant
        this.conversationsListener = db.collection('conversations')
            .where('participants', 'array-contains', this.currentUser.uid)
            .orderBy('lastMessageAt', 'desc')
            .onSnapshot(snapshot => {
                this.handleConversationsUpdate(snapshot);
            }, error => {
                console.error('Conversations listener error:', error);
            });
    }

    async handleConversationsUpdate(snapshot) {
        const conversationsList = document.getElementById('conversationsList');
        if (!conversationsList) return;

        if (snapshot.empty) {
            conversationsList.innerHTML = `
                <div class="empty-conversations">
                    <i class="fas fa-comments"></i>
                    <p>No conversations yet</p>
                    <p>Start a new conversation to begin messaging</p>
                </div>
            `;
            return;
        }

        // Process conversations
        const conversations = [];
        for (const doc of snapshot.docs) {
            const conversation = {
                id: doc.id,
                ...doc.data()
            };
            conversations.push(conversation);
            this.conversations.set(doc.id, conversation);
        }

        // Load user data for all conversations
        await this.loadUsersForConversations(conversations);
        
        this.renderConversationsList(conversations);
    }

    async loadUsersForConversations(conversations) {
        const userIds = new Set();
        
        conversations.forEach(conversation => {
            conversation.participants.forEach(uid => {
                if (uid !== this.currentUser.uid) {
                    userIds.add(uid);
                }
            });
        });

        // Load user data for all participant IDs
        for (const uid of userIds) {
            if (!this.usersCache.has(uid)) {
                try {
                    const userDoc = await db.collection('users').doc(uid).get();
                    if (userDoc.exists) {
                        this.usersCache.set(uid, userDoc.data());
                    } else {
                        // Create a placeholder user object if user document doesn't exist
                        this.usersCache.set(uid, {
                            fullName: 'Unknown User',
                            department: 'Unknown'
                        });
                    }
                } catch (error) {
                    console.error('Error loading user:', error);
                    // Create placeholder on error
                    this.usersCache.set(uid, {
                        fullName: 'Unknown User',
                        department: 'Unknown'
                    });
                }
            }
        }
    }

    renderConversationsList(conversations) {
        const conversationsList = document.getElementById('conversationsList');
        if (!conversationsList) return;

        conversationsList.innerHTML = conversations.map(conversation => {
            const otherParticipantId = conversation.participants.find(uid => uid !== this.currentUser.uid);
            const otherUser = this.usersCache.get(otherParticipantId);
            
            if (!otherUser) {
                return ''; // Skip if user data not loaded
            }
            
            const isActive = this.currentConversation?.id === conversation.id;
            const unreadCount = conversation.unreadCount?.[this.currentUser.uid] || 0;
            const lastMessageTime = conversation.lastMessageAt ? this.formatMessageTime(conversation.lastMessageAt.toDate()) : '';

            return `
                <div class="conversation-item ${isActive ? 'active' : ''}" data-conversation-id="${conversation.id}">
                    <div class="conversation-avatar">
                        ${otherUser.fullName ? otherUser.fullName.charAt(0).toUpperCase() : '?'}
                    </div>
                    <div class="conversation-info">
                        <div class="conversation-name">${otherUser.fullName || 'Unknown User'}</div>
                        <div class="conversation-preview">${conversation.lastMessage || 'No messages yet'}</div>
                    </div>
                    <div class="conversation-meta">
                        <div class="conversation-time">${lastMessageTime}</div>
                        ${unreadCount > 0 ? `<div class="conversation-unread">${unreadCount}</div>` : ''}
                    </div>
                </div>
            `;
        }).join('');

        // Add click listeners
        conversationsList.querySelectorAll('.conversation-item').forEach(item => {
            item.addEventListener('click', () => {
                const conversationId = item.dataset.conversationId;
                this.selectConversation(conversationId);
            });
        });
    }

    async selectConversation(conversationId) {
        const conversation = this.conversations.get(conversationId);
        if (!conversation) return;

        this.currentConversation = conversation;
        
        // Update UI
        document.querySelectorAll('.conversation-item').forEach(item => {
            item.classList.toggle('active', item.dataset.conversationId === conversationId);
        });

        this.renderChatArea(conversation);
        this.loadMessages(conversationId);
        this.markConversationAsRead(conversationId);
    }

    renderChatArea(conversation) {
        const chatArea = document.getElementById('chatArea');
        if (!chatArea) return;

        const otherParticipantId = conversation.participants.find(uid => uid !== this.currentUser.uid);
        const otherUser = this.usersCache.get(otherParticipantId);

        if (!otherUser) {
            console.error('User data not found for participant:', otherParticipantId);
            return;
        }

        chatArea.innerHTML = `
            <div class="chat-header">
                <div class="chat-user-info">
                    <div class="chat-user-avatar">
                        ${otherUser.fullName ? otherUser.fullName.charAt(0).toUpperCase() : '?'}
                    </div>
                    <div class="chat-user-details">
                        <h3>${otherUser.fullName || 'Unknown User'}</h3>
                        <div class="chat-user-status">Online</div>
                    </div>
                </div>
                <div class="chat-actions">
                    <button class="chat-action-btn" title="User info">
                        <i class="fas fa-info-circle"></i>
                    </button>
                    <button class="chat-action-btn mobile-toggle" id="backToConversations">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                </div>
            </div>
            
            <div class="messages-container" id="messagesContainer">
                <div class="loading-messages">
                    <i class="fas fa-spinner fa-spin"></i> Loading messages...
                </div>
            </div>
            
            <div class="typing-indicator hidden" id="typingIndicator"></div>
            
            <div class="chat-input-area">
                <div class="chat-input-container">
                    <button class="attachment-btn" title="Attach file">
                        <i class="fas fa-paperclip"></i>
                    </button>
                    <textarea class="chat-input" id="chatInput" placeholder="Type a message..." rows="1"></textarea>
                    <button class="send-btn" id="sendMessageBtn" title="Send message">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        `;

        // Add event listeners for chat area
        const sendBtn = document.getElementById('sendMessageBtn');
        const chatInput = document.getElementById('chatInput');
        const backBtn = document.getElementById('backToConversations');

        if (sendBtn) {
            sendBtn.addEventListener('click', () => {
                this.sendMessage();
            });
        }

        if (chatInput) {
            chatInput.addEventListener('input', (e) => {
                this.handleTyping();
                this.autoResizeTextarea(e.target);
            });
        }

        if (backBtn) {
            backBtn.addEventListener('click', () => {
                this.showConversationsList();
            });
        }
    }

    async loadMessages(conversationId) {
        const messagesContainer = document.getElementById('messagesContainer');
        if (!messagesContainer) return;

        try {
            // Clean up previous listener
            if (this.messagesListener) {
                this.messagesListener();
            }

            this.messagesListener = db.collection('messages')
                .where('conversationId', '==', conversationId)
                .orderBy('createdAt', 'asc')
                .onSnapshot(snapshot => {
                    this.renderMessages(snapshot.docs);
                }, error => {
                    console.error('Messages listener error:', error);
                });

        } catch (error) {
            console.error('Error loading messages:', error);
            if (messagesContainer) {
                messagesContainer.innerHTML = '<div class="error-message">Error loading messages</div>';
            }
        }
    }

    renderMessages(messageDocs) {
        const messagesContainer = document.getElementById('messagesContainer');
        if (!messagesContainer) return;

        if (messageDocs.length === 0) {
            messagesContainer.innerHTML = `
                <div class="empty-chat">
                    <i class="fas fa-comments"></i>
                    <h3>No messages yet</h3>
                    <p>Send a message to start the conversation</p>
                </div>
            `;
            return;
        }

        messagesContainer.innerHTML = messageDocs.map(doc => {
            const message = doc.data();
            const isSent = message.senderId === this.currentUser.uid;
            
            let senderName = 'Unknown User';
            if (isSent) {
                senderName = this.currentUser.displayName || 'You';
            } else {
                const sender = this.usersCache.get(message.senderId);
                senderName = sender?.fullName || sender?.displayName || 'Unknown User';
            }

            return `
                <div class="message ${isSent ? 'sent' : 'received'}">
                    ${!isSent ? `<div class="message-sender">${senderName}</div>` : ''}
                    <div class="message-content">${message.content || ''}</div>
                    ${message.attachmentUrl ? `
                        <div class="message-attachment">
                            <i class="fas fa-paperclip"></i>
                            <a href="${message.attachmentUrl}" target="_blank">Attachment</a>
                        </div>
                    ` : ''}
                    <div class="message-time">${message.createdAt ? this.formatMessageTime(message.createdAt.toDate()) : ''}</div>
                    ${isSent ? `
                        <div class="message-status">
                            <i class="fas fa-check${message.read ? '-double' : ''}"></i>
                            ${message.read ? 'Read' : 'Delivered'}
                        </div>
                    ` : ''}
                </div>
            `;
        }).join('');

        // Scroll to bottom
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    async sendMessage() {
        const chatInput = document.getElementById('chatInput');
        if (!chatInput || !this.currentConversation) return;

        const content = chatInput.value.trim();
        if (!content) return;

        try {
            const messageData = {
                conversationId: this.currentConversation.id,
                senderId: this.currentUser.uid,
                content: content,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                read: false
            };

            await db.collection('messages').add(messageData);

            // Update conversation last message
            const lastMessagePreview = content.length > 50 ? content.substring(0, 50) + '...' : content;
            
            const updateData = {
                lastMessage: lastMessagePreview,
                lastMessageAt: firebase.firestore.FieldValue.serverTimestamp(),
                [`unreadCount.${this.currentUser.uid}`]: 0 // Reset own unread count
            };

            await db.collection('conversations').doc(this.currentConversation.id).update(updateData);

            // Increment unread count for other participants
            const otherParticipants = this.currentConversation.participants.filter(uid => uid !== this.currentUser.uid);
            const batch = db.batch();
            const conversationRef = db.collection('conversations').doc(this.currentConversation.id);
            
            for (const participantId of otherParticipants) {
                batch.update(conversationRef, {
                    [`unreadCount.${participantId}`]: firebase.firestore.FieldValue.increment(1)
                });
            }
            
            if (otherParticipants.length > 0) {
                await batch.commit();
            }

            chatInput.value = '';
            this.autoResizeTextarea(chatInput);

        } catch (error) {
            console.error('Error sending message:', error);
            showNotification('Error sending message', 'error');
        }
    }

    async showNewConversationModal() {
        const modalHTML = `
            <div class="modal-overlay" id="newConversationModal">
                <div class="modal-content new-conversation-modal">
                    <div class="modal-header">
                        <h3>New Conversation</h3>
                        <button class="close-modal">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="conversations-search">
                            <input type="text" id="userSearch" placeholder="Search users...">
                            <i class="fas fa-search"></i>
                        </div>
                        <div class="users-list" id="usersList">
                            <div class="loading-users">
                                <i class="fas fa-spinner fa-spin"></i> Loading users...
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;

        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        const modal = document.getElementById('newConversationModal');
        const closeBtn = modal.querySelector('.close-modal');
        
        if (closeBtn) {
            closeBtn.addEventListener('click', () => this.closeModal(modal));
        }
        
        modal.addEventListener('click', (e) => {
            if (e.target === modal) this.closeModal(modal);
        });

        await this.loadUsersForNewConversation();
    }

    async loadUsersForNewConversation() {
        const usersList = document.getElementById('usersList');
        if (!usersList) return;

        try {
            // Get all users except current user
            const usersSnapshot = await db.collection('users').get();
            const users = usersSnapshot.docs
                .map(doc => ({ id: doc.id, ...doc.data() }))
                .filter(user => user.id !== this.currentUser.uid);

            this.renderUsersList(users);

            // Add search functionality
            const userSearch = document.getElementById('userSearch');
            if (userSearch) {
                userSearch.addEventListener('input', (e) => {
                    this.filterUsers(users, e.target.value);
                });
            }

        } catch (error) {
            console.error('Error loading users:', error);
            if (usersList) {
                usersList.innerHTML = '<div class="error-message">Error loading users</div>';
            }
        }
    }

    renderUsersList(users) {
        const usersList = document.getElementById('usersList');
        if (!usersList) return;

        if (users.length === 0) {
            usersList.innerHTML = '<div class="empty-state">No users found</div>';
            return;
        }

        usersList.innerHTML = users.map(user => `
            <div class="user-item" data-user-id="${user.id}">
                <div class="user-avatar">
                    ${user.fullName ? user.fullName.charAt(0).toUpperCase() : '?'}
                </div>
                <div class="user-info">
                    <div class="user-name">${user.fullName || 'Unknown User'}</div>
                    <div class="user-department">${user.department || 'No department specified'}</div>
                </div>
            </div>
        `).join('');

        // Add click listeners
        usersList.querySelectorAll('.user-item').forEach(item => {
            item.addEventListener('click', async () => {
                const userId = item.dataset.userId;
                await this.startConversation(userId);
                this.closeModal(document.getElementById('newConversationModal'));
            });
        });
    }

    async startConversation(otherUserId) {
        try {
            // Check if conversation already exists
            const existingConversation = await db.collection('conversations')
                .where('participants', 'array-contains', this.currentUser.uid)
                .get();

            let conversation = existingConversation.docs.find(doc => {
                const data = doc.data();
                return data.participants && data.participants.includes(otherUserId);
            });

            if (conversation) {
                // Use existing conversation
                this.selectConversation(conversation.id);
            } else {
                // Create new conversation
                const conversationData = {
                    participants: [this.currentUser.uid, otherUserId],
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastMessageAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastMessage: 'Conversation started',
                    unreadCount: {
                        [this.currentUser.uid]: 0,
                        [otherUserId]: 0
                    }
                };

                const newConversationRef = await db.collection('conversations').add(conversationData);
                this.selectConversation(newConversationRef.id);
            }

        } catch (error) {
            console.error('Error starting conversation:', error);
            showNotification('Error starting conversation', 'error');
        }
    }

    async markConversationAsRead(conversationId) {
        try {
            await db.collection('conversations').doc(conversationId).update({
                [`unreadCount.${this.currentUser.uid}`]: 0
            });

            // Also mark messages as read
            const unreadMessages = await db.collection('messages')
                .where('conversationId', '==', conversationId)
                .where('senderId', '!=', this.currentUser.uid)
                .where('read', '==', false)
                .get();

            const batch = db.batch();
            unreadMessages.docs.forEach(doc => {
                batch.update(doc.ref, { read: true });
            });
            
            if (!unreadMessages.empty) {
                await batch.commit();
            }

        } catch (error) {
            console.error('Error marking conversation as read:', error);
        }
    }

    handleTyping() {
        // Implement typing indicators if needed
        // This would require additional Firestore documents for typing status
    }

    filterConversations(searchTerm) {
        const term = searchTerm.toLowerCase();
        const conversationItems = document.querySelectorAll('.conversation-item');
        
        conversationItems.forEach(item => {
            const conversationName = item.querySelector('.conversation-name');
            const conversationPreview = item.querySelector('.conversation-preview');
            
            if (conversationName && conversationPreview) {
                const name = conversationName.textContent.toLowerCase();
                const preview = conversationPreview.textContent.toLowerCase();
                
                const matches = name.includes(term) || preview.includes(term);
                item.style.display = matches ? 'flex' : 'none';
            }
        });
    }

    filterUsers(users, searchTerm) {
        const term = searchTerm.toLowerCase();
        const userItems = document.querySelectorAll('.user-item');
        
        userItems.forEach(item => {
            const userName = item.querySelector('.user-name');
            const userDept = item.querySelector('.user-department');
            
            if (userName && userDept) {
                const name = userName.textContent.toLowerCase();
                const dept = userDept.textContent.toLowerCase();
                
                const matches = name.includes(term) || dept.includes(term);
                item.style.display = matches ? 'flex' : 'none';
            }
        });
    }

    autoResizeTextarea(textarea) {
        if (!textarea) return;
        
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }

    formatMessageTime(date) {
        if (!date) return '';
        
        const now = new Date();
        const diff = now - date;
        
        const minute = 60 * 1000;
        const hour = minute * 60;
        const day = hour * 24;
        
        if (diff < minute) return 'Now';
        if (diff < hour) return `${Math.floor(diff / minute)}m`;
        if (diff < day) return `${Math.floor(diff / hour)}h`;
        if (diff < day * 7) return `${Math.floor(diff / day)}d`;
        
        return date.toLocaleDateString();
    }

    showConversationsList() {
        // For mobile view - show conversations list
        const sidebar = document.getElementById('conversationsSidebar');
        const chatArea = document.getElementById('chatArea');
        
        if (sidebar) sidebar.classList.add('mobile-visible');
        if (chatArea) chatArea.classList.add('mobile-hidden');
    }

    showLoginPrompt() {
        const messagesContainer = document.getElementById('messages');
        if (messagesContainer) {
            messagesContainer.innerHTML = `
                <div class="empty-chat">
                    <i class="fas fa-sign-in-alt"></i>
                    <h3>Please Sign In</h3>
                    <p>You need to be signed in to use the messaging system</p>
                    <button class="btn btn-primary mt-20" onclick="showPage('login')">
                        Sign In
                    </button>
                </div>
            `;
        }
    }

    closeModal(modal) {
        if (modal) modal.remove();
    }

    cleanup() {
        if (this.conversationsListener) {
            this.conversationsListener();
        }
        if (this.messagesListener) {
            this.messagesListener();
        }
        if (this.typingTimeout) {
            clearTimeout(this.typingTimeout);
        }
    }
}

// Initialize messaging system when messages page is active
function initMessagingPage() {
    const messagesPage = document.getElementById('messages');
    if (messagesPage && messagesPage.classList.contains('active')) {
        console.log('Initializing messaging page...');
        
        const messagingManager = new MessagingManager();
        messagingManager.init();
        
        // Make it globally available
        window.messagingManager = messagingManager;
    }
}

// Listen for page navigation to messages
document.addEventListener('DOMContentLoaded', () => {
    initMessagingPage();
    
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                if (mutation.target.id === 'messages' && mutation.target.classList.contains('active')) {
                    initMessagingPage();
                }
            }
        });
    });
    
    const messagesPage = document.getElementById('messages');
    if (messagesPage) {
        observer.observe(messagesPage, { attributes: true });
    }
});

// Firestore Security Rules for Messaging (add to your rules):
/*
// Conversations rules
match /conversations/{conversationId} {
  allow read, write: if request.auth != null 
    && request.auth.uid in resource.data.participants;
  allow create: if request.auth != null 
    && request.auth.uid in request.resource.data.participants;
}

// Messages rules
match /messages/{messageId} {
  allow read: if request.auth != null 
    && request.auth.uid in get(/databases/$(database)/documents/conversations/$(resource.data.conversationId)).data.participants;
  allow create: if request.auth != null 
    && request.auth.uid == request.resource.data.senderId
    && request.auth.uid in get(/databases/$(database)/documents/conversations/$(request.resource.data.conversationId)).data.participants;
}
*/

// Utility functions for testing
window.messagingUtils = {
    createSampleConversations: async () => {
        if (!auth.currentUser) {
            showNotification('Please sign in first', 'error');
            return;
        }

        try {
            // Get some other users
            const usersSnapshot = await db.collection('users').limit(3).get();
            const otherUsers = usersSnapshot.docs
                .map(doc => ({ id: doc.id, ...doc.data() }))
                .filter(user => user.id !== auth.currentUser.uid);

            if (otherUsers.length === 0) {
                showNotification('No other users found to start conversations with', 'info');
                return;
            }

            for (const user of otherUsers) {
                const conversationData = {
                    participants: [auth.currentUser.uid, user.id],
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastMessageAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastMessage: 'Hello! ',
                    unreadCount: {
                        [auth.currentUser.uid]: 0,
                        [user.id]: 1
                    }
                };

                const conversationRef = await db.collection('conversations').add(conversationData);

                // Add sample messages
                const messages = [
                    { 
                        sender: user.id, 
                        content: `Hi! I'm ${user.fullName || 'another user'}. Nice to meet you!` 
                    },
                    { 
                        sender: auth.currentUser.uid, 
                        content: "Hello! Great to connect with you." 
                    },
                    { 
                        sender: user.id, 
                        content: "How are you finding the platform so far?" 
                    },
                    { 
                        sender: auth.currentUser.uid, 
                        content: "It's amazing! The features are really helpful for students." 
                    }
                ];

                for (const message of messages) {
                    await db.collection('messages').add({
                        conversationId: conversationRef.id,
                        senderId: message.sender,
                        content: message.content,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        read: message.sender === auth.currentUser.uid
                    });
                }
            }

            showNotification('Sample conversations created!', 'success');

        } catch (error) {
            console.error('Error creating sample conversations:', error);
            showNotification('Error creating conversations: ' + error.message, 'error');
        }
    },

    clearAllMessages: async () => {
        if (!confirm('This will delete ALL messages and conversations. Are you sure?')) return;
        
        try {
            // Delete all conversations
            const conversationsSnapshot = await db.collection('conversations').get();
            const conversationsBatch = db.batch();
            conversationsSnapshot.docs.forEach(doc => {
                conversationsBatch.delete(doc.ref);
            });
            await conversationsBatch.commit();

            // Delete all messages
            const messagesSnapshot = await db.collection('messages').get();
            const messagesBatch = db.batch();
            messagesSnapshot.docs.forEach(doc => {
                messagesBatch.delete(doc.ref);
            });
            await messagesBatch.commit();

            showNotification('All messages cleared!', 'success');

            if (window.messagingManager) {
                window.messagingManager.loadConversations();
            }

        } catch (error) {
            console.error('Error clearing messages:', error);
            showNotification('Error clearing messages: ' + error.message, 'error');
        }
    }
};

console.log('Messaging system module loaded successfully!');
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        // ===============================
// User Profiles & Enhanced Messaging
// ===============================

// Add CSS for user profiles and enhanced messaging
const profilesMessagingCSS = `
/* User Profile Styles */
.profile-modal .modal-content {
    max-width: 600px;
}

.profile-header {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    padding: 20px;
    background: linear-gradient(135deg, var(--secondary), var(--primary));
    color: white;
    border-radius: 8px;
}

.profile-avatar-large {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: rgba(255,255,255,0.2);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    font-weight: bold;
    border: 3px solid white;
}

.profile-info-large {
    flex: 1;
}

.profile-name {
    font-size: 1.5rem;
    font-weight: bold;
    margin-bottom: 5px;
}

.profile-department {
    font-size: 1rem;
    opacity: 0.9;
    margin-bottom: 10px;
}

.profile-stats {
    display: flex;
    gap: 20px;
}

.profile-stat {
    text-align: center;
}

.profile-stat-value {
    font-size: 1.2rem;
    font-weight: bold;
}

.profile-stat-label {
    font-size: 0.8rem;
    opacity: 0.8;
}

.profile-details {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-bottom: 20px;
}

.profile-detail {
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
}

.detail-label {
    font-size: 0.8rem;
    color: var(--gray);
    margin-bottom: 5px;
}

.detail-value {
    font-weight: 500;
}

.profile-actions {
    display: flex;
    gap: 10px;
    margin-top: 20px;
}

.message-request-btn {
    background: var(--secondary);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    flex: 1;
}

.view-posts-btn {
    background: var(--primary);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    flex: 1;
}

/* Message Requests */
.requests-sidebar {
    border-right: 1px solid #eee;
    display: flex;
    flex-direction: column;
    width: 300px;
}

.requests-header {
    padding: 20px;
    border-bottom: 1px solid #eee;
}

.requests-list {
    flex: 1;
    overflow-y: auto;
}

.request-item {
    padding: 15px 20px;
    border-bottom: 1px solid #f5f5f5;
    cursor: pointer;
    transition: background-color 0.3s ease;
    display: flex;
    align-items: center;
    gap: 12px;
}

.request-item:hover {
    background: #f8f9fa;
}

.request-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--secondary);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
}

.request-info {
    flex: 1;
}

.request-name {
    font-weight: 600;
    margin-bottom: 4px;
}

.request-message {
    font-size: 0.8rem;
    color: var(--gray);
}

.request-actions {
    display: flex;
    gap: 5px;
}

.request-action-btn {
    background: none;
    border: none;
    padding: 5px;
    cursor: pointer;
    border-radius: 4px;
    font-size: 0.8rem;
}

.accept-btn {
    color: var(--success);
    border: 1px solid var(--success);
}

.decline-btn {
    color: var(--danger);
    border: 1px solid var(--danger);
}

/* Enhanced Messaging Container */
.enhanced-messaging-container {
    display: grid;
    grid-template-columns: 300px 350px 1fr;
    gap: 0;
    height: 70vh;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    overflow: hidden;
}

.requests-count {
    background: var(--accent);
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 0.7rem;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: 8px;
}

/* Search in Messages */
.messages-search {
    position: relative;
    margin: 15px 20px;
}

.messages-search input {
    width: 100%;
    padding: 10px 35px 10px 15px;
    border: 1px solid #ddd;
    border-radius: 20px;
    font-size: 0.9rem;
}

.messages-search i {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--gray);
}

/* Message Search Results */
.search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 100;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.search-result-item {
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid #f5f5f5;
}

.search-result-item:hover {
    background: #f8f9fa;
}

.search-result-content {
    font-size: 0.9rem;
    margin-bottom: 4px;
}

.search-result-meta {
    font-size: 0.7rem;
    color: var(--gray);
    display: flex;
    justify-content: space-between;
}

/* Message Context */
.message-context {
    background: #f8f9fa;
    padding: 10px 15px;
    border-bottom: 1px solid #eee;
    font-size: 0.8rem;
    color: var(--gray);
}

.message-context strong {
    color: var(--secondary);
}

/* Online Status */
.status-online {
    color: var(--success);
}

.status-offline {
    color: var(--gray);
}

.status-away {
    color: var(--warning);
}

/* Typing Animation */
.typing-dots {
    display: inline-flex;
    gap: 2px;
}

.typing-dot {
    width: 4px;
    height: 4px;
    background: var(--gray);
    border-radius: 50%;
    animation: typingAnimation 1.4s infinite ease-in-out;
}

.typing-dot:nth-child(1) { animation-delay: -0.32s; }
.typing-dot:nth-child(2) { animation-delay: -0.16s; }

@keyframes typingAnimation {
    0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
    40% { transform: scale(1); opacity: 1; }
}

/* Message Reactions */
.message-reactions {
    display: flex;
    gap: 5px;
    margin-top: 5px;
    flex-wrap: wrap;
}

.reaction {
    background: rgba(255,255,255,0.2);
    padding: 2px 6px;
    border-radius: 12px;
    font-size: 0.7rem;
    display: flex;
    align-items: center;
    gap: 2px;
    cursor: pointer;
}

.message.received .reaction {
    background: #f0f0f0;
}

.reaction-count {
    font-size: 0.6rem;
}

/* Message Options */
.message-options {
    position: absolute;
    top: 5px;
    right: 5px;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.message:hover .message-options {
    opacity: 1;
}

.message-option-btn {
    background: none;
    border: none;
    color: inherit;
    cursor: pointer;
    padding: 2px;
    font-size: 0.7rem;
    opacity: 0.7;
}

.message-option-btn:hover {
    opacity: 1;
}

/* Responsive Design */
@media (max-width: 1024px) {
    .enhanced-messaging-container {
        grid-template-columns: 1fr;
    }
    
    .requests-sidebar,
    .conversations-sidebar {
        display: none;
    }
    
    .requests-sidebar.mobile-visible,
    .conversations-sidebar.mobile-visible {
        display: flex;
    }
}

@media (max-width: 768px) {
    .profile-details {
        grid-template-columns: 1fr;
    }
    
    .profile-actions {
        flex-direction: column;
    }
}

/* Empty States */
.empty-requests {
    padding: 40px 20px;
    text-align: center;
    color: var(--gray);
}

.empty-requests i {
    font-size: 3rem;
    margin-bottom: 15px;
    opacity: 0.5;
}
`;

// Add CSS to document
const profilesMessagingStyleSheet = document.createElement('style');
profilesMessagingStyleSheet.textContent = profilesMessagingCSS;
document.head.appendChild(profilesMessagingStyleSheet);

// Enhanced Messaging System with User Profiles
class EnhancedMessagingManager {
    constructor() {
        this.currentUser = null;
        this.currentConversation = null;
        this.currentView = 'conversations'; // 'conversations' or 'requests'
        this.conversationsListener = null;
        this.messagesListener = null;
        this.requestsListener = null;
        this.usersListener = null;
        this.conversations = new Map();
        this.usersCache = new Map();
        this.messageRequests = new Map();
        this.typingTimeouts = new Map();
    }

    init() {
        console.log('EnhancedMessagingManager initializing...');
        
        auth.onAuthStateChanged(user => {
            this.currentUser = user;
            if (user) {
                this.setupRealTimeListeners();
                this.renderEnhancedMessagingUI();
                this.loadCurrentUserProfile();
            } else {
                this.cleanup();
                this.showLoginPrompt();
            }
        });
    }

    renderEnhancedMessagingUI() {
        const messagesContainer = document.getElementById('messages');
        if (!messagesContainer) return;

        messagesContainer.innerHTML = `
            <div class="enhanced-messaging-container">
                <!-- Message Requests Sidebar -->
                <div class="requests-sidebar" id="requestsSidebar">
                    <div class="requests-header">
                        <h3>Message Requests</h3>
                    </div>
                    <div class="requests-list" id="requestsList">
                        <div class="loading-requests">
                            <i class="fas fa-spinner fa-spin"></i> Loading requests...
                        </div>
                    </div>
                </div>
                
                <!-- Conversations Sidebar -->
                <div class="conversations-sidebar" id="conversationsSidebar">
                    <div class="conversations-header">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                            <h3 style="margin: 0; display: flex; align-items: center;">
                                Conversations
                                <span class="requests-count hidden" id="requestsCount">0</span>
                            </h3>
                            <button class="chat-action-btn" id="toggleRequests" title="Toggle requests view">
                                <i class="fas fa-user-friends"></i>
                            </button>
                        </div>
                        <div class="conversations-search">
                            <input type="text" id="conversationsSearch" placeholder="Search conversations...">
                            <i class="fas fa-search"></i>
                        </div>
                        <button class="new-conversation-btn" id="newConversationBtn">
                            <i class="fas fa-plus"></i> New Conversation
                        </button>
                    </div>
                    <div class="conversations-list" id="conversationsList">
                        <div class="loading-conversations">
                            <i class="fas fa-spinner fa-spin"></i> Loading conversations...
                        </div>
                    </div>
                </div>
                
                <!-- Chat Area -->
                <div class="chat-area" id="chatArea">
                    <div class="no-conversation-selected">
                        <i class="fas fa-comment-alt"></i>
                        <h3>Select a conversation</h3>
                        <p>Choose a conversation from the sidebar or start a new one</p>
                    </div>
                </div>
            </div>
        `;

        this.setupEnhancedEventListeners();
    }

    setupEnhancedEventListeners() {
        // New conversation button
        const newConversationBtn = document.getElementById('newConversationBtn');
        if (newConversationBtn) {
            newConversationBtn.addEventListener('click', () => {
                this.showNewConversationModal();
            });
        }

        // Toggle requests view
        const toggleRequestsBtn = document.getElementById('toggleRequests');
        if (toggleRequestsBtn) {
            toggleRequestsBtn.addEventListener('click', () => {
                this.toggleRequestsView();
            });
        }

        // Search functionality
        const searchInput = document.getElementById('conversationsSearch');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                this.filterConversations(e.target.value);
            });
        }

        // Message search in chat
        document.addEventListener('input', (e) => {
            if (e.target.id === 'messageSearch') {
                this.searchMessages(e.target.value);
            }
        });

        // Send message on Enter key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.classList.contains('chat-input') && !e.shiftKey) {
                e.preventDefault();
                this.sendMessage();
            }
        });
    }

    setupRealTimeListeners() {
        if (!this.currentUser) return;

        // Listen for conversations
        this.conversationsListener = db.collection('conversations')
            .where('participants', 'array-contains', this.currentUser.uid)
            .orderBy('lastMessageAt', 'desc')
            .onSnapshot(snapshot => {
                this.handleConversationsUpdate(snapshot);
            });

        // Listen for message requests
        this.requestsListener = db.collection('messageRequests')
            .where('receiverId', '==', this.currentUser.uid)
            .where('status', '==', 'pending')
            .orderBy('createdAt', 'desc')
            .onSnapshot(snapshot => {
                this.handleMessageRequestsUpdate(snapshot);
            });

        // Listen for users for quick profile access
        this.usersListener = db.collection('users')
            .onSnapshot(snapshot => {
                snapshot.docChanges().forEach(change => {
                    if (change.type === 'added' || change.type === 'modified') {
                        this.usersCache.set(change.doc.id, change.doc.data());
                    }
                });
            });
    }

    async handleMessageRequestsUpdate(snapshot) {
        const requestsList = document.getElementById('requestsList');
        const requestsCount = document.getElementById('requestsCount');
        
        if (!requestsList) return;

        if (snapshot.empty) {
            requestsList.innerHTML = `
                <div class="empty-requests">
                    <i class="fas fa-inbox"></i>
                    <p>No message requests</p>
                </div>
            `;
            if (requestsCount) {
                requestsCount.classList.add('hidden');
            }
            return;
        }

        // Process requests
        const requests = [];
        for (const doc of snapshot.docs) {
            const request = {
                id: doc.id,
                ...doc.data()
            };
            requests.push(request);
            this.messageRequests.set(doc.id, request);
        }

        // Load user data for requests
        await this.loadUsersForRequests(requests);
        this.renderMessageRequests(requests);

        // Update requests count
        if (requestsCount) {
            requestsCount.textContent = requests.length;
            requestsCount.classList.remove('hidden');
        }
    }

    async loadUsersForRequests(requests) {
        const userIds = new Set();
        
        requests.forEach(request => {
            userIds.add(request.senderId);
        });

        for (const uid of userIds) {
            if (!this.usersCache.has(uid)) {
                try {
                    const userDoc = await db.collection('users').doc(uid).get();
                    if (userDoc.exists) {
                        this.usersCache.set(uid, userDoc.data());
                    }
                } catch (error) {
                    console.error('Error loading user for request:', error);
                }
            }
        }
    }

    renderMessageRequests(requests) {
        const requestsList = document.getElementById('requestsList');
        if (!requestsList) return;

        requestsList.innerHTML = requests.map(request => {
            const sender = this.usersCache.get(request.senderId);
            if (!sender) return '';

            return `
                <div class="request-item" data-request-id="${request.id}">
                    <div class="request-avatar" onclick="event.stopPropagation(); enhancedMessagingManager.showUserProfile('${request.senderId}')">
                        ${sender.fullName ? sender.fullName.charAt(0).toUpperCase() : '?'}
                    </div>
                    <div class="request-info">
                        <div class="request-name">${sender.fullName || 'Unknown User'}</div>
                        <div class="request-message">${request.message || 'Wants to connect with you'}</div>
                    </div>
                    <div class="request-actions">
                        <button class="request-action-btn accept-btn" onclick="event.stopPropagation(); enhancedMessagingManager.acceptMessageRequest('${request.id}')">
                            <i class="fas fa-check"></i>
                        </button>
                        <button class="request-action-btn decline-btn" onclick="event.stopPropagation(); enhancedMessagingManager.declineMessageRequest('${request.id}')">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
            `;
        }).join('');
    }

    async handleConversationsUpdate(snapshot) {
        const conversationsList = document.getElementById('conversationsList');
        if (!conversationsList) return;

        if (snapshot.empty) {
            conversationsList.innerHTML = `
                <div class="empty-conversations">
                    <i class="fas fa-comments"></i>
                    <p>No conversations yet</p>
                    <p>Start a new conversation to begin messaging</p>
                </div>
            `;
            return;
        }

        // Process conversations
        const conversations = [];
        for (const doc of snapshot.docs) {
            const conversation = {
                id: doc.id,
                ...doc.data()
            };
            conversations.push(conversation);
            this.conversations.set(doc.id, conversation);
        }

        await this.loadUsersForConversations(conversations);
        this.renderConversationsList(conversations);
    }

    async loadUsersForConversations(conversations) {
        const userIds = new Set();
        
        conversations.forEach(conversation => {
            conversation.participants.forEach(uid => {
                if (uid !== this.currentUser.uid) {
                    userIds.add(uid);
                }
            });
        });

        for (const uid of userIds) {
            if (!this.usersCache.has(uid)) {
                try {
                    const userDoc = await db.collection('users').doc(uid).get();
                    if (userDoc.exists) {
                        this.usersCache.set(uid, userDoc.data());
                    }
                } catch (error) {
                    console.error('Error loading user:', error);
                }
            }
        }
    }

    renderConversationsList(conversations) {
        const conversationsList = document.getElementById('conversationsList');
        if (!conversationsList) return;

        conversationsList.innerHTML = conversations.map(conversation => {
            const otherParticipantId = conversation.participants.find(uid => uid !== this.currentUser.uid);
            const otherUser = this.usersCache.get(otherParticipantId);
            
            if (!otherUser) return '';

            const isActive = this.currentConversation?.id === conversation.id;
            const unreadCount = conversation.unreadCount?.[this.currentUser.uid] || 0;
            const lastMessageTime = conversation.lastMessageAt ? this.formatMessageTime(conversation.lastMessageAt.toDate()) : '';

            return `
                <div class="conversation-item ${isActive ? 'active' : ''}" data-conversation-id="${conversation.id}">
                    <div class="conversation-avatar" onclick="event.stopPropagation(); enhancedMessagingManager.showUserProfile('${otherParticipantId}')">
                        ${otherUser.fullName ? otherUser.fullName.charAt(0).toUpperCase() : '?'}
                    </div>
                    <div class="conversation-info">
                        <div class="conversation-name">${otherUser.fullName || 'Unknown User'}</div>
                        <div class="conversation-preview">${conversation.lastMessage || 'No messages yet'}</div>
                    </div>
                    <div class="conversation-meta">
                        <div class="conversation-time">${lastMessageTime}</div>
                        ${unreadCount > 0 ? `<div class="conversation-unread">${unreadCount}</div>` : ''}
                    </div>
                </div>
            `;
        }).join('');

        // Add click listeners
        conversationsList.querySelectorAll('.conversation-item').forEach(item => {
            item.addEventListener('click', () => {
                const conversationId = item.dataset.conversationId;
                this.selectConversation(conversationId);
            });
        });
    }

    async selectConversation(conversationId) {
        const conversation = this.conversations.get(conversationId);
        if (!conversation) return;

        this.currentConversation = conversation;
        
        // Update UI
        document.querySelectorAll('.conversation-item').forEach(item => {
            item.classList.toggle('active', item.dataset.conversationId === conversationId);
        });

        this.renderEnhancedChatArea(conversation);
        this.loadMessages(conversationId);
        this.markConversationAsRead(conversationId);
    }

    renderEnhancedChatArea(conversation) {
        const chatArea = document.getElementById('chatArea');
        if (!chatArea) return;

        const otherParticipantId = conversation.participants.find(uid => uid !== this.currentUser.uid);
        const otherUser = this.usersCache.get(otherParticipantId);

        if (!otherUser) return;

        chatArea.innerHTML = `
            <div class="chat-header">
                <div class="chat-user-info">
                    <div class="chat-user-avatar" onclick="enhancedMessagingManager.showUserProfile('${otherParticipantId}')">
                        ${otherUser.fullName ? otherUser.fullName.charAt(0).toUpperCase() : '?'}
                    </div>
                    <div class="chat-user-details">
                        <h3>${otherUser.fullName || 'Unknown User'}</h3>
                        <div class="chat-user-status status-online">
                            <i class="fas fa-circle"></i> Online
                        </div>
                    </div>
                </div>
                <div class="chat-actions">
                    <div class="messages-search">
                        <input type="text" id="messageSearch" placeholder="Search in conversation...">
                        <i class="fas fa-search"></i>
                        <div class="search-results hidden" id="searchResults"></div>
                    </div>
                    <button class="chat-action-btn" title="User info" onclick="enhancedMessagingManager.showUserProfile('${otherParticipantId}')">
                        <i class="fas fa-info-circle"></i>
                    </button>
                    <button class="chat-action-btn mobile-toggle" id="backToConversations">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                </div>
            </div>
            
            <div class="messages-container" id="messagesContainer">
                <div class="loading-messages">
                    <i class="fas fa-spinner fa-spin"></i> Loading messages...
                </div>
            </div>
            
            <div class="typing-indicator hidden" id="typingIndicator"></div>
            
            <div class="chat-input-area">
                <div class="chat-input-container">
                    <button class="attachment-btn" title="Attach file">
                        <i class="fas fa-paperclip"></i>
                    </button>
                    <textarea class="chat-input" id="chatInput" placeholder="Type a message..." rows="1"></textarea>
                    <button class="send-btn" id="sendMessageBtn" title="Send message">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        `;

        // Add event listeners
        const sendBtn = document.getElementById('sendMessageBtn');
        const chatInput = document.getElementById('chatInput');
        const backBtn = document.getElementById('backToConversations');
        const messageSearch = document.getElementById('messageSearch');

        if (sendBtn) {
            sendBtn.addEventListener('click', () => this.sendMessage());
        }

        if (chatInput) {
            chatInput.addEventListener('input', (e) => {
                this.handleTyping();
                this.autoResizeTextarea(e.target);
            });
        }

        if (backBtn) {
            backBtn.addEventListener('click', () => this.showConversationsList());
        }

        if (messageSearch) {
            messageSearch.addEventListener('focus', () => {
                this.setupMessageSearch();
            });
        }
    }

    async showUserProfile(userId) {
        const user = this.usersCache.get(userId);
        if (!user) {
            try {
                const userDoc = await db.collection('users').doc(userId).get();
                if (userDoc.exists) {
                    this.usersCache.set(userId, userDoc.data());
                    this.showUserProfileModal(userId, userDoc.data());
                } else {
                    showNotification('User profile not found', 'error');
                }
            } catch (error) {
                console.error('Error loading user profile:', error);
                showNotification('Error loading profile', 'error');
            }
        } else {
            this.showUserProfileModal(userId, user);
        }
    }

    showUserProfileModal(userId, userData) {
        const modalHTML = `
            <div class="modal-overlay profile-modal" id="userProfileModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>User Profile</h3>
                        <button class="close-modal">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="profile-header">
                            <div class="profile-avatar-large">
                                ${userData.fullName ? userData.fullName.charAt(0).toUpperCase() : '?'}
                            </div>
                            <div class="profile-info-large">
                                <div class="profile-name">${userData.fullName || 'Unknown User'}</div>
                                <div class="profile-department">${userData.department || 'No department specified'}</div>
                                <div class="profile-stats">
                                    <div class="profile-stat">
                                        <div class="profile-stat-value">${userData.postsCount || 0}</div>
                                        <div class="profile-stat-label">Posts</div>
                                    </div>
                                    <div class="profile-stat">
                                        <div class="profile-stat-value">${userData.commentsCount || 0}</div>
                                        <div class="profile-stat-label">Comments</div>
                                    </div>
                                    <div class="profile-stat">
                                        <div class="profile-stat-value">${userData.likesCount || 0}</div>
                                        <div class="profile-stat-label">Likes</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="profile-details">
                            <div class="profile-detail">
                                <div class="detail-label">Student ID</div>
                                <div class="detail-value">${userData.studentId || 'Not provided'}</div>
                            </div>
                            <div class="profile-detail">
                                <div class="detail-label">Year of Study</div>
                                <div class="detail-value">${userData.year ? `Year ${userData.year}` : 'Not specified'}</div>
                            </div>
                            <div class="profile-detail">
                                <div class="detail-label">Email</div>
                                <div class="detail-value">${userData.email || 'Not provided'}</div>
                            </div>
                            <div class="profile-detail">
                                <div class="detail-label">Member Since</div>
                                <div class="detail-value">${userData.createdAt ? userData.createdAt.toDate().toLocaleDateString() : 'Unknown'}</div>
                            </div>
                        </div>
                        
                        <div class="profile-actions">
                            ${userId !== this.currentUser.uid ? `
                                <button class="message-request-btn" id="sendMessageRequest">
                                    <i class="fas fa-envelope"></i> Send Message Request
                                </button>
                                <button class="view-posts-btn" onclick="enhancedMessagingManager.viewUserPosts('${userId}')">
                                    <i class="fas fa-file-alt"></i> View Posts
                                </button>
                            ` : `
                                <button class="message-request-btn" onclick="showPage('profile')">
                                    <i class="fas fa-user-edit"></i> Edit My Profile
                                </button>
                            `}
                        </div>
                    </div>
                </div>
            </div>
        `;

        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        const modal = document.getElementById('userProfileModal');
        const closeBtn = modal.querySelector('.close-modal');
        
        if (closeBtn) {
            closeBtn.addEventListener('click', () => this.closeModal(modal));
        }
        
        modal.addEventListener('click', (e) => {
            if (e.target === modal) this.closeModal(modal);
        });

        // Add message request functionality
        if (userId !== this.currentUser.uid) {
            const sendRequestBtn = document.getElementById('sendMessageRequest');
            if (sendRequestBtn) {
                sendRequestBtn.addEventListener('click', () => {
                    this.sendMessageRequest(userId);
                    this.closeModal(modal);
                });
            }
        }
    }

    async sendMessageRequest(receiverId) {
        try {
            // Check if request already exists
            const existingRequest = await db.collection('messageRequests')
                .where('senderId', '==', this.currentUser.uid)
                .where('receiverId', '==', receiverId)
                .where('status', '==', 'pending')
                .get();

            if (!existingRequest.empty) {
                showNotification('Message request already sent', 'info');
                return;
            }

            // Check if conversation already exists
            const existingConversation = await db.collection('conversations')
                .where('participants', 'array-contains', this.currentUser.uid)
                .get();

            const conversationExists = existingConversation.docs.find(doc => 
                doc.data().participants.includes(receiverId)
            );

            if (conversationExists) {
                showNotification('You already have a conversation with this user', 'info');
                return;
            }

            // Create message request
            const requestData = {
                senderId: this.currentUser.uid,
                receiverId: receiverId,
                message: `${this.currentUser.displayName || 'Someone'} wants to connect with you`,
                status: 'pending',
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            await db.collection('messageRequests').add(requestData);
            showNotification('Message request sent successfully', 'success');

        } catch (error) {
            console.error('Error sending message request:', error);
            showNotification('Error sending message request', 'error');
        }
    }

    async acceptMessageRequest(requestId) {
        try {
            const request = this.messageRequests.get(requestId);
            if (!request) return;

            // Update request status
            await db.collection('messageRequests').doc(requestId).update({
                status: 'accepted',
                acceptedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            // Create conversation
            const conversationData = {
                participants: [this.currentUser.uid, request.senderId],
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                lastMessageAt: firebase.firestore.FieldValue.serverTimestamp(),
                lastMessage: 'Connected through message request',
                unreadCount: {
                    [this.currentUser.uid]: 0,
                    [request.senderId]: 0
                }
            };

            const conversationRef = await db.collection('conversations').add(conversationData);
            
            // Add welcome message
            await db.collection('messages').add({
                conversationId: conversationRef.id,
                senderId: this.currentUser.uid,
                content: "Hi! I accepted your message request. How can I help you?",
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                read: false
            });

            showNotification('Message request accepted', 'success');
            this.selectConversation(conversationRef.id);

        } catch (error) {
            console.error('Error accepting message request:', error);
            showNotification('Error accepting request', 'error');
        }
    }

    async declineMessageRequest(requestId) {
        try {
            await db.collection('messageRequests').doc(requestId).update({
                status: 'declined',
                declinedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            showNotification('Message request declined', 'info');
        } catch (error) {
            console.error('Error declining message request:', error);
            showNotification('Error declining request', 'error');
        }
    }

    async searchMessages(searchTerm) {
        if (!this.currentConversation || !searchTerm.trim()) {
            const searchResults = document.getElementById('searchResults');
            if (searchResults) searchResults.classList.add('hidden');
            return;
        }

        try {
            const messagesSnapshot = await db.collection('messages')
                .where('conversationId', '==', this.currentConversation.id)
                .orderBy('createdAt', 'desc')
                .get();

            const results = messagesSnapshot.docs
                .map(doc => ({ id: doc.id, ...doc.data() }))
                .filter(message => 
                    message.content && 
                    message.content.toLowerCase().includes(searchTerm.toLowerCase())
                )
                .slice(0, 5); // Limit results

            this.displaySearchResults(results, searchTerm);

        } catch (error) {
            console.error('Error searching messages:', error);
        }
    }

    displaySearchResults(results, searchTerm) {
        const searchResults = document.getElementById('searchResults');
        if (!searchResults) return;

        if (results.length === 0) {
            searchResults.innerHTML = '<div class="search-result-item">No results found</div>';
            searchResults.classList.remove('hidden');
            return;
        }

        searchResults.innerHTML = results.map(message => {
            const sender = this.usersCache.get(message.senderId);
            const senderName = sender?.fullName || 'Unknown User';
            const content = this.highlightText(message.content, searchTerm);
            const time = message.createdAt ? this.formatMessageTime(message.createdAt.toDate()) : '';

            return `
                <div class="search-result-item" onclick="enhancedMessagingManager.jumpToMessage('${message.id}')">
                    <div class="search-result-content">${content}</div>
                    <div class="search-result-meta">
                        <span>${senderName}</span>
                        <span>${time}</span>
                    </div>
                </div>
            `;
        }).join('');

        searchResults.classList.remove('hidden');
    }

    highlightText(text, searchTerm) {
        const regex = new RegExp(`(${searchTerm})`, 'gi');
        return text.replace(regex, '<mark>$1</mark>');
    }

    async jumpToMessage(messageId) {
        // Implementation to scroll to and highlight a specific message
        const messagesContainer = document.getElementById('messagesContainer');
        const messageElement = messagesContainer.querySelector(`[data-message-id="${messageId}"]`);
        
        if (messageElement) {
            messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            messageElement.style.backgroundColor = '#fff3cd';
            setTimeout(() => {
                messageElement.style.backgroundColor = '';
            }, 2000);
        }

        // Hide search results
        const searchResults = document.getElementById('searchResults');
        if (searchResults) searchResults.classList.add('hidden');
        
        const messageSearch = document.getElementById('messageSearch');
        if (messageSearch) messageSearch.value = '';
    }

    toggleRequestsView() {
        const requestsSidebar = document.getElementById('requestsSidebar');
        const conversationsSidebar = document.getElementById('conversationsSidebar');
        
        if (requestsSidebar && conversationsSidebar) {
            const isRequestsVisible = !requestsSidebar.classList.contains('mobile-visible');
            
            if (isRequestsVisible) {
                requestsSidebar.classList.add('mobile-visible');
                conversationsSidebar.classList.remove('mobile-visible');
            } else {
                requestsSidebar.classList.remove('mobile-visible');
                conversationsSidebar.classList.add('mobile-visible');
            }
        }
    }

    async loadCurrentUserProfile() {
        if (!this.currentUser) return;

        try {
            const userDoc = await db.collection('users').doc(this.currentUser.uid).get();
            if (userDoc.exists) {
                this.usersCache.set(this.currentUser.uid, userDoc.data());
            }
        } catch (error) {
            console.error('Error loading current user profile:', error);
        }
    }

    viewUserPosts(userId) {
        showNotification('Redirecting to user posts...', 'info');
        // Implementation to filter and show user's posts
        console.log('View posts for user:', userId);
    }

    // Override previous methods with enhanced versions
    async sendMessage() {
        const chatInput = document.getElementById('chatInput');
        if (!chatInput || !this.currentConversation) return;

        const content = chatInput.value.trim();
        if (!content) return;

        try {
            const messageData = {
                conversationId: this.currentConversation.id,
                senderId: this.currentUser.uid,
                content: content,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                read: false
            };

            await db.collection('messages').add(messageData);

            // Update conversation
            const lastMessagePreview = content.length > 50 ? content.substring(0, 50) + '...' : content;
            
            await db.collection('conversations').doc(this.currentConversation.id).update({
                lastMessage: lastMessagePreview,
                lastMessageAt: firebase.firestore.FieldValue.serverTimestamp(),
                [`unreadCount.${this.currentUser.uid}`]: 0
            });

            // Update unread counts for other participants
            const otherParticipants = this.currentConversation.participants.filter(uid => uid !== this.currentUser.uid);
            const batch = db.batch();
            const conversationRef = db.collection('conversations').doc(this.currentConversation.id);
            
            for (const participantId of otherParticipants) {
                batch.update(conversationRef, {
                    [`unreadCount.${participantId}`]: firebase.firestore.FieldValue.increment(1)
                });
            }
            
            if (otherParticipants.length > 0) {
                await batch.commit();
            }

            chatInput.value = '';
            this.autoResizeTextarea(chatInput);

        } catch (error) {
            console.error('Error sending message:', error);
            showNotification('Error sending message', 'error');
        }
    }

    // Keep other existing methods from previous implementation
    setupMessageSearch() {
        // Additional setup for message search
    }

    handleTyping() {
        // Enhanced typing indicators
    }

    autoResizeTextarea(textarea) {
        if (!textarea) return;
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }

    formatMessageTime(date) {
        if (!date) return '';
        const now = new Date();
        const diff = now - date;
        
        const minute = 60 * 1000;
        const hour = minute * 60;
        const day = hour * 24;
        
        if (diff < minute) return 'Now';
        if (diff < hour) return `${Math.floor(diff / minute)}m`;
        if (diff < day) return `${Math.floor(diff / hour)}h`;
        if (diff < day * 7) return `${Math.floor(diff / day)}d`;
        
        return date.toLocaleDateString();
    }

    showConversationsList() {
        const sidebar = document.getElementById('conversationsSidebar');
        const chatArea = document.getElementById('chatArea');
        
        if (sidebar) sidebar.classList.add('mobile-visible');
        if (chatArea) chatArea.classList.add('mobile-hidden');
    }

    showLoginPrompt() {
        const messagesContainer = document.getElementById('messages');
        if (messagesContainer) {
            messagesContainer.innerHTML = `
                <div class="empty-chat">
                    <i class="fas fa-sign-in-alt"></i>
                    <h3>Please Sign In</h3>
                    <p>You need to be signed in to use the messaging system</p>
                    <button class="btn btn-primary mt-20" onclick="showPage('login')">
                        Sign In
                    </button>
                </div>
            `;
        }
    }

    closeModal(modal) {
        if (modal) modal.remove();
    }

    cleanup() {
        if (this.conversationsListener) this.conversationsListener();
        if (this.messagesListener) this.messagesListener();
        if (this.requestsListener) this.requestsListener();
        if (this.usersListener) this.usersListener();
        
        this.typingTimeouts.forEach(timeout => clearTimeout(timeout));
        this.typingTimeouts.clear();
    }
}

// Replace the previous messaging initialization with enhanced version
function initEnhancedMessagingPage() {
    const messagesPage = document.getElementById('messages');
    if (messagesPage && messagesPage.classList.contains('active')) {
        console.log('Initializing enhanced messaging page...');
        
        const enhancedMessagingManager = new EnhancedMessagingManager();
        enhancedMessagingManager.init();
        
        // Make it globally available
        window.enhancedMessagingManager = enhancedMessagingManager;
    }
}

// Update the page navigation listener
document.addEventListener('DOMContentLoaded', () => {
    initEnhancedMessagingPage();
    
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                if (mutation.target.id === 'messages' && mutation.target.classList.contains('active')) {
                    initEnhancedMessagingPage();
                }
            }
        });
    });
    
    const messagesPage = document.getElementById('messages');
    if (messagesPage) {
        observer.observe(messagesPage, { attributes: true });
    }
});

// Firestore Security Rules for Enhanced Messaging (add to your rules):
/*
// Message Requests rules
match /messageRequests/{requestId} {
  allow read: if request.auth != null 
    && (request.auth.uid == resource.data.receiverId || request.auth.uid == resource.data.senderId);
  allow create: if request.auth != null 
    && request.auth.uid == request.resource.data.senderId
    && request.resource.data.receiverId != request.auth.uid;
  allow update: if request.auth != null 
    && request.auth.uid == resource.data.receiverId;
}

// Users rules (for profile viewing)
match /users/{userId} {
  allow read: if request.auth != null;
  allow write: if request.auth != null && request.auth.uid == userId;
}
*/

// Utility to make users clickable throughout the app
document.addEventListener('click', (e) => {
    // Make user avatars and names clickable in posts and comments
    if (e.target.classList.contains('post-author') || 
        e.target.classList.contains('comment-author') ||
        e.target.closest('.post-author') || 
        e.target.closest('.comment-author')) {
        
        const authorElement = e.target.classList.contains('post-author') || e.target.classList.contains('comment-author') 
            ? e.target 
            : e.target.closest('.post-author') || e.target.closest('.comment-author');
        
        const authorId = authorElement.dataset.userId;
        if (authorId && window.enhancedMessagingManager) {
            e.preventDefault();
            e.stopPropagation();
            window.enhancedMessagingManager.showUserProfile(authorId);
        }
    }
});

// Add user IDs to post and comment elements in your existing social features
// Modify your post and comment creation functions to include:
// data-user-id="${post.authorId}" on author elements

console.log('Enhanced messaging with user profiles loaded successfully!');
        
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       // ===============================
// User Display & Profile Integration Fix
// ===============================

// Add CSS for better user display
const userDisplayCSS = `
/* User Display Enhancements */
.clickable-user {
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
}

.clickable-user:hover {
    transform: translateY(-1px);
}

.clickable-user .avatar {
    transition: transform 0.3s ease;
}

.clickable-user:hover .avatar {
    transform: scale(1.1);
}

.user-display-name {
    font-weight: 600;
    color: var(--secondary);
    text-decoration: none;
}

.user-display-name:hover {
    text-decoration: underline;
}

.user-badge {
    background: var(--secondary);
    color: white;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 0.7rem;
    margin-left: 5px;
}

.user-department {
    font-size: 0.8rem;
    color: var(--gray);
    margin-top: 2px;
}

.quick-message-btn {
    background: var(--secondary);
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 0.7rem;
    cursor: pointer;
    margin-left: 8px;
    transition: background-color 0.3s ease;
}

.quick-message-btn:hover {
    background: var(--primary);
}

.post-author-enhanced {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 10px;
    padding: 10px;
    background: #f8f9fa;
    border-radius: 8px;
}

.author-main-info {
    display: flex;
    align-items: center;
    gap: 10px;
}

.author-actions {
    display: flex;
    gap: 5px;
}

.user-profile-tooltip {
    position: absolute;
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    z-index: 1000;
    min-width: 200px;
    display: none;
}

.user-profile-tooltip.show {
    display: block;
}

.tooltip-avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: var(--secondary);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 1.2rem;
    margin-bottom: 10px;
}

.tooltip-name {
    font-weight: bold;
    margin-bottom: 5px;
}

.tooltip-department {
    color: var(--gray);
    font-size: 0.9rem;
    margin-bottom: 10px;
}

.tooltip-actions {
    display: flex;
    gap: 5px;
}

.tooltip-btn {
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    font-size: 0.8rem;
    cursor: pointer;
    flex: 1;
}

.tooltip-message {
    background: var(--secondary);
    color: white;
}

.tooltip-view {
    background: var(--primary);
    color: white;
}

/* Enhanced post headers */
.post-header-enhanced {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #eee;
}

.author-info-complete {
    display: flex;
    align-items: center;
    gap: 12px;
}

.author-details {
    display: flex;
    flex-direction: column;
}

.author-name-container {
    display: flex;
    align-items: center;
    gap: 8px;
}

.author-stats {
    display: flex;
    gap: 15px;
    margin-top: 5px;
}

.author-stat {
    font-size: 0.8rem;
    color: var(--gray);
}

/* Comment author enhancements */
.comment-author-enhanced {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.comment-author-details {
    display: flex;
    flex-direction: column;
}

.comment-author-name {
    font-weight: 600;
    font-size: 0.9rem;
}

.comment-author-department {
    font-size: 0.7rem;
    color: var(--gray);
}
`;

// Add CSS to document
const userDisplayStyleSheet = document.createElement('style');
userDisplayStyleSheet.textContent = userDisplayCSS;
document.head.appendChild(userDisplayStyleSheet);

// User Display Manager
class UserDisplayManager {
    constructor() {
        this.usersCache = new Map();
        this.currentUser = null;
    }

    init() {
        console.log('UserDisplayManager initializing...');
        
        auth.onAuthStateChanged(user => {
            this.currentUser = user;
            if (user) {
                this.setupUserListeners();
                this.enhanceExistingUserDisplays();
            }
        });

        // Enhance user displays when new content is added
        this.setupMutationObserver();
    }

    setupUserListeners() {
        // Listen for all users to cache their data
        db.collection('users').onSnapshot(snapshot => {
            snapshot.docChanges().forEach(change => {
                if (change.type === 'added' || change.type === 'modified') {
                    this.usersCache.set(change.doc.id, change.doc.data());
                    this.updateUserDisplays(change.doc.id, change.doc.data());
                }
            });
        });
    }

    setupMutationObserver() {
        // Watch for new posts and comments to enhance user displays
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'childList') {
                    mutation.addedNodes.forEach(node => {
                        if (node.nodeType === 1) { // Element node
                            this.enhanceUserDisplaysInElement(node);
                        }
                    });
                }
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    }

    enhanceExistingUserDisplays() {
        // Enhance all existing user displays
        const postsContainer = document.getElementById('postsContainer');
        if (postsContainer) {
            this.enhanceUserDisplaysInElement(postsContainer);
        }

        const discussionsContainer = document.getElementById('discussionsContainer');
        if (discussionsContainer) {
            this.enhanceUserDisplaysInElement(discussionsContainer);
        }
    }

    enhanceUserDisplaysInElement(element) {
        // Enhance post authors
        const postAuthors = element.querySelectorAll('.post-author, [class*="author"]');
        postAuthors.forEach(authorElement => {
            this.enhanceAuthorDisplay(authorElement);
        });

        // Enhance comment authors
        const commentAuthors = element.querySelectorAll('.comment-author, .comment-header');
        commentAuthors.forEach(authorElement => {
            this.enhanceCommentAuthorDisplay(authorElement);
        });
    }

    enhanceAuthorDisplay(authorElement) {
        // Find the user ID from data attributes or parent elements
        let userId = authorElement.dataset.userId;
        
        if (!userId) {
            // Try to find user ID from parent post
            const postElement = authorElement.closest('[data-post-id], .post-card, .discussion-card');
            if (postElement && postElement.dataset.authorId) {
                userId = postElement.dataset.authorId;
            }
        }

        if (userId) {
            this.createEnhancedAuthorDisplay(authorElement, userId);
        }
    }

    enhanceCommentAuthorDisplay(authorElement) {
        let userId = authorElement.dataset.userId;
        
        if (!userId) {
            const commentElement = authorElement.closest('.comment, [data-comment-id]');
            if (commentElement && commentElement.dataset.authorId) {
                userId = commentElement.dataset.authorId;
            }
        }

        if (userId) {
            this.createEnhancedCommentAuthorDisplay(authorElement, userId);
        }
    }

    async createEnhancedAuthorDisplay(authorElement, userId) {
        const userData = await this.getUserData(userId);
        
        // Replace the existing author display with enhanced version
        authorElement.innerHTML = `
            <div class="author-info-complete">
                <div class="clickable-user" onclick="userDisplayManager.showUserProfile('${userId}')">
                    <div class="avatar">
                        ${userData.fullName ? userData.fullName.charAt(0).toUpperCase() : '?'}
                    </div>
                </div>
                <div class="author-details">
                    <div class="author-name-container">
                        <span class="user-display-name" onclick="userDisplayManager.showUserProfile('${userId}')">
                            ${userData.fullName || 'Loading...'}
                        </span>
                        ${userData.department ? `<span class="user-badge">${userData.department}</span>` : ''}
                    </div>
                    <div class="author-stats">
                        <span class="author-stat">${userData.postsCount || 0} posts</span>
                        <span class="author-stat">${userData.commentsCount || 0} comments</span>
                        <span class="author-stat">${userData.likesCount || 0} likes</span>
                    </div>
                </div>
            </div>
            ${userId !== this.currentUser?.uid ? `
                <div class="author-actions">
                    <button class="quick-message-btn" onclick="userDisplayManager.quickMessage('${userId}')">
                        <i class="fas fa-envelope"></i> Message
                    </button>
                </div>
            ` : ''}
        `;

        // Store user ID for future reference
        authorElement.dataset.userId = userId;
    }

    async createEnhancedCommentAuthorDisplay(authorElement, userId) {
        const userData = await this.getUserData(userId);
        
        authorElement.innerHTML = `
            <div class="comment-author-enhanced">
                <div class="clickable-user" onclick="userDisplayManager.showUserProfile('${userId}')">
                    <div class="avatar small">
                        ${userData.fullName ? userData.fullName.charAt(0).toUpperCase() : '?'}
                    </div>
                </div>
                <div class="comment-author-details">
                    <div class="comment-author-name" onclick="userDisplayManager.showUserProfile('${userId}')">
                        ${userData.fullName || 'Loading...'}
                    </div>
                    ${userData.department ? `
                        <div class="comment-author-department">${userData.department}</div>
                    ` : ''}
                </div>
                ${userId !== this.currentUser?.uid ? `
                    <button class="quick-message-btn" onclick="userDisplayManager.quickMessage('${userId}')">
                        <i class="fas fa-envelope"></i>
                    </button>
                ` : ''}
            </div>
        `;

        authorElement.dataset.userId = userId;
    }

    async getUserData(userId) {
        // Check cache first
        if (this.usersCache.has(userId)) {
            return this.usersCache.get(userId);
        }

        // Fetch from Firestore
        try {
            const userDoc = await db.collection('users').doc(userId).get();
            if (userDoc.exists) {
                const userData = userDoc.data();
                this.usersCache.set(userId, userData);
                return userData;
            } else {
                // Return default data if user not found
                return {
                    fullName: 'Unknown User',
                    department: 'Unknown',
                    postsCount: 0,
                    commentsCount: 0,
                    likesCount: 0
                };
            }
        } catch (error) {
            console.error('Error fetching user data:', error);
            return {
                fullName: 'Error Loading',
                department: 'Unknown',
                postsCount: 0,
                commentsCount: 0,
                likesCount: 0
            };
        }
    }

    updateUserDisplays(userId, userData) {
        // Update all instances of this user in the UI
        const userElements = document.querySelectorAll(`[data-user-id="${userId}"]`);
        userElements.forEach(element => {
            if (element.classList.contains('post-author') || element.closest('.post-author')) {
                this.createEnhancedAuthorDisplay(element, userId);
            } else if (element.classList.contains('comment-author') || element.closest('.comment-author')) {
                this.createEnhancedCommentAuthorDisplay(element, userId);
            }
        });
    }

    async showUserProfile(userId) {
        if (window.enhancedMessagingManager) {
            window.enhancedMessagingManager.showUserProfile(userId);
        } else {
            // Fallback profile viewer
            this.showBasicUserProfile(userId);
        }
    }

    async showBasicUserProfile(userId) {
        const userData = await this.getUserData(userId);
        
        const modalHTML = `
            <div class="modal-overlay" id="userProfileModal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>User Profile</h3>
                        <button class="close-modal">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="profile-header">
                            <div class="profile-avatar-large">
                                ${userData.fullName ? userData.fullName.charAt(0).toUpperCase() : '?'}
                            </div>
                            <div class="profile-info-large">
                                <div class="profile-name">${userData.fullName || 'Unknown User'}</div>
                                <div class="profile-department">${userData.department || 'No department specified'}</div>
                            </div>
                        </div>
                        <div class="profile-actions">
                            <button class="message-request-btn" onclick="userDisplayManager.quickMessage('${userId}')">
                                <i class="fas fa-envelope"></i> Send Message
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        const modal = document.getElementById('userProfileModal');
        modal.querySelector('.close-modal').addEventListener('click', () => modal.remove());
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.remove();
        });
    }

    async quickMessage(userId) {
        if (window.enhancedMessagingManager) {
            // Use enhanced messaging system
            window.enhancedMessagingManager.sendMessageRequest(userId);
        } else if (window.messagingManager) {
            // Use basic messaging system
            window.messagingManager.startConversation(userId);
        } else {
            // Fallback: show profile with message option
            this.showUserProfile(userId);
        }
    }
}

// Modify the SocialFeatures class to use real user data
class EnhancedSocialFeatures {
    constructor() {
        this.userDisplayManager = new UserDisplayManager();
    }

    init() {
        console.log('EnhancedSocialFeatures initializing...');
        this.userDisplayManager.init();
        
        // Override post creation to include proper user data
        this.overridePostCreation();
        this.overrideCommentCreation();
    }

    overridePostCreation() {
        // Store original method
        const originalCreatePostElement = window.socialFeatures?.createPostElement;
        
        if (originalCreatePostElement) {
            window.socialFeatures.createPostElement = (post, postId) => {
                const postElement = originalCreatePostElement.call(window.socialFeatures, post, postId);
                
                // Add author ID to post element
                postElement.dataset.authorId = post.authorId;
                
                // Enhance author display immediately
                const authorElement = postElement.querySelector('.post-author');
                if (authorElement) {
                    authorElement.dataset.userId = post.authorId;
                    this.userDisplayManager.enhanceAuthorDisplay(authorElement);
                }
                
                return postElement;
            };
        }
    }

    overrideCommentCreation() {
        const originalCreateCommentElement = window.socialFeatures?.createCommentElement;
        
        if (originalCreateCommentElement) {
            window.socialFeatures.createCommentElement = (comment, commentId) => {
                const commentElement = originalCreateCommentElement.call(window.socialFeatures, comment, commentId);
                
                // Add author ID to comment element
                commentElement.dataset.authorId = comment.authorId;
                
                // Enhance author display immediately
                const authorElement = commentElement.querySelector('.comment-header, .comment-author');
                if (authorElement) {
                    authorElement.dataset.userId = comment.authorId;
                    this.userDisplayManager.enhanceCommentAuthorDisplay(authorElement);
                }
                
                return commentElement;
            };
        }
    }
}

// Modify the createPost function to ensure proper user data is saved
function enhanceCreatePostFunction() {
    const originalHandleCreatePost = window.socialFeatures?.handleCreatePost;
    
    if (originalHandleCreatePost) {
        window.socialFeatures.handleCreatePost = async function(e, modal) {
            e.preventDefault();
            
            const title = document.getElementById('postTitle').value;
            const content = document.getElementById('postContent').value;
            const imageFile = document.getElementById('postImage').files[0];
            
            try {
                let imageUrl = '';
                
                if (imageFile) {
                    imageUrl = await this.uploadImage(imageFile);
                }
                
                // Get current user data from Firestore to ensure we have full information
                const currentUser = auth.currentUser;
                let userData = {
                    fullName: currentUser.displayName || 'Unknown User',
                    department: 'Unknown',
                    studentId: 'Unknown'
                };
                
                try {
                    const userDoc = await db.collection('users').doc(currentUser.uid).get();
                    if (userDoc.exists) {
                        userData = userDoc.data();
                    }
                } catch (error) {
                    console.error('Error fetching user data for post:', error);
                }
                
                const postData = {
                    title,
                    content,
                    authorId: currentUser.uid,
                    authorName: userData.fullName,
                    authorDepartment: userData.department,
                    authorStudentId: userData.studentId,
                    imageUrl,
                    likesCount: 0,
                    dislikesCount: 0,
                    commentsCount: 0,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                await db.collection('posts').add(postData);
                
                showNotification('Post created successfully!', 'success');
                this.closeModal(modal);
                
            } catch (error) {
                console.error('Error creating post:', error);
                showNotification('Error creating post: ' + error.message, 'error');
            }
        };
    }
}

// Modify the comment creation to use proper user data
function enhanceCommentFunctions() {
    const originalPostComment = window.socialFeatures?.postComment;
    
    if (originalPostComment) {
        window.socialFeatures.postComment = async function(postId) {
            if (!this.currentUser) {
                showNotification('Please log in to comment', 'error');
                return;
            }
            
            const commentInput = document.querySelector(`#comments-${postId} .comment-input`);
            const content = commentInput.value.trim();
            
            if (!content) {
                showNotification('Please enter a comment', 'error');
                return;
            }
            
            try {
                // Get current user data from Firestore
                const currentUser = auth.currentUser;
                let userData = {
                    fullName: currentUser.displayName || 'Unknown User',
                    department: 'Unknown'
                };
                
                try {
                    const userDoc = await db.collection('users').doc(currentUser.uid).get();
                    if (userDoc.exists) {
                        userData = userDoc.data();
                    }
                } catch (error) {
                    console.error('Error fetching user data for comment:', error);
                }
                
                await db.collection('comments').add({
                    postId,
                    content,
                    authorId: currentUser.uid,
                    authorName: userData.fullName,
                    authorDepartment: userData.department,
                    parentCommentId: null,
                    likesCount: 0,
                    dislikesCount: 0,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                commentInput.value = '';
                showNotification('Comment posted!', 'success');
            } catch (error) {
                console.error('Error posting comment:', error);
                showNotification('Error posting comment: ' + error.message, 'error');
            }
        };
    }
}

// Initialize enhanced user display system
document.addEventListener('DOMContentLoaded', () => {
    console.log('Initializing enhanced user display system...');
    
    const enhancedSocialFeatures = new EnhancedSocialFeatures();
    enhancedSocialFeatures.init();
    
    // Enhance existing create post and comment functions
    enhanceCreatePostFunction();
    enhanceCommentFunctions();
    
    // Make user display manager globally available
    window.userDisplayManager = enhancedSocialFeatures.userDisplayManager;
});

// Update Discussions Manager to use enhanced user displays
function enhanceDiscussionsManager() {
    const originalCreateDiscussionCard = window.discussionsManager?.createDiscussionCard;
    
    if (originalCreateDiscussionCard) {
        window.discussionsManager.createDiscussionCard = function(post) {
            const cardElement = originalCreateDiscussionCard.call(this, post);
            
            // Add author ID to discussion card
            cardElement.dataset.authorId = post.authorId;
            
            // Enhance author display
            const authorElement = cardElement.querySelector('.discussion-author, .discussion-meta');
            if (authorElement) {
                authorElement.dataset.userId = post.authorId;
                if (window.userDisplayManager) {
                    setTimeout(() => {
                        window.userDisplayManager.enhanceAuthorDisplay(authorElement);
                    }, 100);
                }
            }
            
            return cardElement;
        };
    }
}

// Update the user registration to ensure complete user data is saved
function enhanceUserRegistration() {
    const originalHandleSignup = window.handleSignup;
    
    if (originalHandleSignup) {
        window.handleSignup = async function(e) {
            e.preventDefault();
            
            const fullName = document.getElementById('signupFullName').value;
            const email = document.getElementById('signupEmail').value;
            const password = document.getElementById('signupPassword').value;
            const department = document.getElementById('signupDepartment').value;
            const year = document.getElementById('signupYear').value;
            const studentId = document.getElementById('signupStudentId').value;
            
            try {
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                const user = userCredential.user;
                
                // Update user profile with display name
                await user.updateProfile({
                    displayName: fullName
                });
                
                // Save complete user data to Firestore
                const userData = {
                    fullName: fullName,
                    email: email,
                    department: department,
                    year: year,
                    studentId: studentId,
                    postsCount: 0,
                    commentsCount: 0,
                    likesCount: 0,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                await db.collection('users').doc(user.uid).set(userData);
                
                showNotification('Account created successfully!', 'success');
                showPage('profile');
                
            } catch (error) {
                console.error('Error creating account:', error);
                showNotification(error.message, 'error');
            }
        };
    }
}

// Update the login function to ensure user data is cached
function enhanceUserLogin() {
    auth.onAuthStateChanged(async (user) => {
        if (user) {
            // Ensure user data is loaded into cache
            try {
                const userDoc = await db.collection('users').doc(user.uid).get();
                if (userDoc.exists) {
                    if (window.userDisplayManager) {
                        window.userDisplayManager.usersCache.set(user.uid, userDoc.data());
                    }
                }
            } catch (error) {
                console.error('Error loading user data on login:', error);
            }
        }
    });
}

// Initialize all enhancements
setTimeout(() => {
    enhanceDiscussionsManager();
    enhanceUserRegistration();
    enhanceUserLogin();
}, 1000);

console.log('User display enhancement system loaded successfully!');
       
       
       
        
        
    </script>
    
    
    

    
    
    
</body>
</html>
